import {
  __assign,
  __extends,
  __read,
  __spreadArray,
  __values
} from "./chunk-TDMZ27IZ.js";
import {
  writable
} from "./chunk-23TPTTRL.js";
import "./chunk-2M4JNLCF.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_dev,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  component_subscribe,
  compute_rest_props,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  set_dynamic_element_data,
  set_store_value,
  set_svg_attributes,
  space,
  svg_element,
  transition_in,
  transition_out,
  update_slot_base,
  validate_dynamic_element,
  validate_slots,
  validate_store,
  validate_void_dynamic_element
} from "./chunk-MPEMMLY7.js";
import "./chunk-U6XRYDZX.js";
import {
  __export
} from "./chunk-EQ4POWW4.js";

// node_modules/@material/dialog/util.js
var util_exports = {};
__export(util_exports, {
  areTopsMisaligned: () => areTopsMisaligned,
  createFocusTrapInstance: () => createFocusTrapInstance,
  isScrollAtBottom: () => isScrollAtBottom,
  isScrollAtTop: () => isScrollAtTop,
  isScrollable: () => isScrollable
});
function createFocusTrapInstance(surfaceEl, focusTrapFactory, initialFocusEl) {
  return focusTrapFactory(surfaceEl, { initialFocusEl });
}
function isScrollable(el) {
  return el ? el.scrollHeight > el.offsetHeight : false;
}
function isScrollAtTop(el) {
  return el ? el.scrollTop === 0 : false;
}
function isScrollAtBottom(el) {
  return el ? Math.ceil(el.scrollHeight - el.scrollTop) === el.clientHeight : false;
}
function areTopsMisaligned(els) {
  var tops = /* @__PURE__ */ new Set();
  [].forEach.call(els, function(el) {
    return tops.add(el.offsetTop);
  });
  return tops.size > 1;
}

// node_modules/@material/base/foundation.js
var MDCFoundation = (
  /** @class */
  function() {
    function MDCFoundation2(adapter) {
      if (adapter === void 0) {
        adapter = {};
      }
      this.adapter = adapter;
    }
    Object.defineProperty(MDCFoundation2, "cssClasses", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFoundation2, "strings", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFoundation2, "numbers", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFoundation2, "defaultAdapter", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    MDCFoundation2.prototype.init = function() {
    };
    MDCFoundation2.prototype.destroy = function() {
    };
    return MDCFoundation2;
  }()
);

// node_modules/@material/base/component.js
var MDCComponent = (
  /** @class */
  function() {
    function MDCComponent2(root, foundation) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      this.root = root;
      this.initialize.apply(this, __spreadArray([], __read(args)));
      this.foundation = foundation === void 0 ? this.getDefaultFoundation() : foundation;
      this.foundation.init();
      this.initialSyncWithDOM();
    }
    MDCComponent2.attachTo = function(root) {
      return new MDCComponent2(root, new MDCFoundation({}));
    };
    MDCComponent2.prototype.initialize = function() {
      var _args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        _args[_i] = arguments[_i];
      }
    };
    MDCComponent2.prototype.getDefaultFoundation = function() {
      throw new Error("Subclasses must override getDefaultFoundation to return a properly configured foundation class");
    };
    MDCComponent2.prototype.initialSyncWithDOM = function() {
    };
    MDCComponent2.prototype.destroy = function() {
      this.foundation.destroy();
    };
    MDCComponent2.prototype.listen = function(evtType, handler, options) {
      this.root.addEventListener(evtType, handler, options);
    };
    MDCComponent2.prototype.unlisten = function(evtType, handler, options) {
      this.root.removeEventListener(evtType, handler, options);
    };
    MDCComponent2.prototype.emit = function(evtType, evtData, shouldBubble) {
      if (shouldBubble === void 0) {
        shouldBubble = false;
      }
      var evt;
      if (typeof CustomEvent === "function") {
        evt = new CustomEvent(evtType, {
          bubbles: shouldBubble,
          detail: evtData
        });
      } else {
        evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(evtType, shouldBubble, false, evtData);
      }
      this.root.dispatchEvent(evt);
    };
    return MDCComponent2;
  }()
);

// node_modules/@material/dom/focus-trap.js
var focus_trap_exports = {};
__export(focus_trap_exports, {
  FocusTrap: () => FocusTrap
});
var FOCUS_SENTINEL_CLASS = "mdc-dom-focus-sentinel";
var FocusTrap = (
  /** @class */
  function() {
    function FocusTrap2(root, options) {
      if (options === void 0) {
        options = {};
      }
      this.root = root;
      this.options = options;
      this.elFocusedBeforeTrapFocus = null;
    }
    FocusTrap2.prototype.trapFocus = function() {
      var focusableEls = this.getFocusableElements(this.root);
      if (focusableEls.length === 0) {
        throw new Error("FocusTrap: Element must have at least one focusable child.");
      }
      this.elFocusedBeforeTrapFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
      this.wrapTabFocus(this.root);
      if (!this.options.skipInitialFocus) {
        this.focusInitialElement(focusableEls, this.options.initialFocusEl);
      }
    };
    FocusTrap2.prototype.releaseFocus = function() {
      [].slice.call(this.root.querySelectorAll("." + FOCUS_SENTINEL_CLASS)).forEach(function(sentinelEl) {
        sentinelEl.parentElement.removeChild(sentinelEl);
      });
      if (!this.options.skipRestoreFocus && this.elFocusedBeforeTrapFocus) {
        this.elFocusedBeforeTrapFocus.focus();
      }
    };
    FocusTrap2.prototype.wrapTabFocus = function(el) {
      var _this = this;
      var sentinelStart = this.createSentinel();
      var sentinelEnd = this.createSentinel();
      sentinelStart.addEventListener("focus", function() {
        var focusableEls = _this.getFocusableElements(el);
        if (focusableEls.length > 0) {
          focusableEls[focusableEls.length - 1].focus();
        }
      });
      sentinelEnd.addEventListener("focus", function() {
        var focusableEls = _this.getFocusableElements(el);
        if (focusableEls.length > 0) {
          focusableEls[0].focus();
        }
      });
      el.insertBefore(sentinelStart, el.children[0]);
      el.appendChild(sentinelEnd);
    };
    FocusTrap2.prototype.focusInitialElement = function(focusableEls, initialFocusEl) {
      var focusIndex = 0;
      if (initialFocusEl) {
        focusIndex = Math.max(focusableEls.indexOf(initialFocusEl), 0);
      }
      focusableEls[focusIndex].focus();
    };
    FocusTrap2.prototype.getFocusableElements = function(root) {
      var focusableEls = [].slice.call(root.querySelectorAll("[autofocus], [tabindex], a, input, textarea, select, button"));
      return focusableEls.filter(function(el) {
        var isDisabledOrHidden = el.getAttribute("aria-disabled") === "true" || el.getAttribute("disabled") != null || el.getAttribute("hidden") != null || el.getAttribute("aria-hidden") === "true";
        var isTabbableAndVisible = el.tabIndex >= 0 && el.getBoundingClientRect().width > 0 && !el.classList.contains(FOCUS_SENTINEL_CLASS) && !isDisabledOrHidden;
        var isProgrammaticallyHidden = false;
        if (isTabbableAndVisible) {
          var style = getComputedStyle(el);
          isProgrammaticallyHidden = style.display === "none" || style.visibility === "hidden";
        }
        return isTabbableAndVisible && !isProgrammaticallyHidden;
      });
    };
    FocusTrap2.prototype.createSentinel = function() {
      var sentinel = document.createElement("div");
      sentinel.setAttribute("tabindex", "0");
      sentinel.setAttribute("aria-hidden", "true");
      sentinel.classList.add(FOCUS_SENTINEL_CLASS);
      return sentinel;
    };
    return FocusTrap2;
  }()
);

// node_modules/@material/dom/ponyfill.js
var ponyfill_exports = {};
__export(ponyfill_exports, {
  closest: () => closest,
  estimateScrollWidth: () => estimateScrollWidth,
  matches: () => matches
});
function closest(element2, selector) {
  if (element2.closest) {
    return element2.closest(selector);
  }
  var el = element2;
  while (el) {
    if (matches(el, selector)) {
      return el;
    }
    el = el.parentElement;
  }
  return null;
}
function matches(element2, selector) {
  var nativeMatches = element2.matches || element2.webkitMatchesSelector || element2.msMatchesSelector;
  return nativeMatches.call(element2, selector);
}
function estimateScrollWidth(element2) {
  var htmlEl = element2;
  if (htmlEl.offsetParent !== null) {
    return htmlEl.scrollWidth;
  }
  var clone = htmlEl.cloneNode(true);
  clone.style.setProperty("position", "absolute");
  clone.style.setProperty("transform", "translate(-9999px, -9999px)");
  document.documentElement.appendChild(clone);
  var scrollWidth = clone.scrollWidth;
  document.documentElement.removeChild(clone);
  return scrollWidth;
}

// node_modules/@material/dom/events.js
function applyPassive(globalObj) {
  if (globalObj === void 0) {
    globalObj = window;
  }
  return supportsPassiveOption(globalObj) ? { passive: true } : false;
}
function supportsPassiveOption(globalObj) {
  if (globalObj === void 0) {
    globalObj = window;
  }
  var passiveSupported = false;
  try {
    var options = {
      // This function will be called when the browser
      // attempts to access the passive property.
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    var handler = function() {
    };
    globalObj.document.addEventListener("test", handler, options);
    globalObj.document.removeEventListener("test", handler, options);
  } catch (err) {
    passiveSupported = false;
  }
  return passiveSupported;
}

// node_modules/@material/ripple/constants.js
var cssClasses = {
  // Ripple is a special case where the "root" component is really a "mixin" of sorts,
  // given that it's an 'upgrade' to an existing component. That being said it is the root
  // CSS class that all other CSS classes derive from.
  BG_FOCUSED: "mdc-ripple-upgraded--background-focused",
  FG_ACTIVATION: "mdc-ripple-upgraded--foreground-activation",
  FG_DEACTIVATION: "mdc-ripple-upgraded--foreground-deactivation",
  ROOT: "mdc-ripple-upgraded",
  UNBOUNDED: "mdc-ripple-upgraded--unbounded"
};
var strings = {
  VAR_FG_SCALE: "--mdc-ripple-fg-scale",
  VAR_FG_SIZE: "--mdc-ripple-fg-size",
  VAR_FG_TRANSLATE_END: "--mdc-ripple-fg-translate-end",
  VAR_FG_TRANSLATE_START: "--mdc-ripple-fg-translate-start",
  VAR_LEFT: "--mdc-ripple-left",
  VAR_TOP: "--mdc-ripple-top"
};
var numbers = {
  DEACTIVATION_TIMEOUT_MS: 225,
  FG_DEACTIVATION_MS: 150,
  INITIAL_ORIGIN_SCALE: 0.6,
  PADDING: 10,
  TAP_DELAY_MS: 300
  // Delay between touch and simulated mouse events on touch devices
};

// node_modules/@material/ripple/util.js
var supportsCssVariables_;
function supportsCssVariables(windowObj, forceRefresh) {
  if (forceRefresh === void 0) {
    forceRefresh = false;
  }
  var CSS = windowObj.CSS;
  var supportsCssVars = supportsCssVariables_;
  if (typeof supportsCssVariables_ === "boolean" && !forceRefresh) {
    return supportsCssVariables_;
  }
  var supportsFunctionPresent = CSS && typeof CSS.supports === "function";
  if (!supportsFunctionPresent) {
    return false;
  }
  var explicitlySupportsCssVars = CSS.supports("--css-vars", "yes");
  var weAreFeatureDetectingSafari10plus = CSS.supports("(--css-vars: yes)") && CSS.supports("color", "#00000000");
  supportsCssVars = explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus;
  if (!forceRefresh) {
    supportsCssVariables_ = supportsCssVars;
  }
  return supportsCssVars;
}
function getNormalizedEventCoords(evt, pageOffset, clientRect) {
  if (!evt) {
    return { x: 0, y: 0 };
  }
  var x = pageOffset.x, y = pageOffset.y;
  var documentX = x + clientRect.left;
  var documentY = y + clientRect.top;
  var normalizedX;
  var normalizedY;
  if (evt.type === "touchstart") {
    var touchEvent = evt;
    normalizedX = touchEvent.changedTouches[0].pageX - documentX;
    normalizedY = touchEvent.changedTouches[0].pageY - documentY;
  } else {
    var mouseEvent = evt;
    normalizedX = mouseEvent.pageX - documentX;
    normalizedY = mouseEvent.pageY - documentY;
  }
  return { x: normalizedX, y: normalizedY };
}

// node_modules/@material/ripple/foundation.js
var ACTIVATION_EVENT_TYPES = [
  "touchstart",
  "pointerdown",
  "mousedown",
  "keydown"
];
var POINTER_DEACTIVATION_EVENT_TYPES = [
  "touchend",
  "pointerup",
  "mouseup",
  "contextmenu"
];
var activatedTargets = [];
var MDCRippleFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCRippleFoundation2, _super);
    function MDCRippleFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCRippleFoundation2.defaultAdapter), adapter)) || this;
      _this.activationAnimationHasEnded = false;
      _this.activationTimer = 0;
      _this.fgDeactivationRemovalTimer = 0;
      _this.fgScale = "0";
      _this.frame = { width: 0, height: 0 };
      _this.initialSize = 0;
      _this.layoutFrame = 0;
      _this.maxRadius = 0;
      _this.unboundedCoords = { left: 0, top: 0 };
      _this.activationState = _this.defaultActivationState();
      _this.activationTimerCallback = function() {
        _this.activationAnimationHasEnded = true;
        _this.runDeactivationUXLogicIfReady();
      };
      _this.activateHandler = function(e) {
        _this.activateImpl(e);
      };
      _this.deactivateHandler = function() {
        _this.deactivateImpl();
      };
      _this.focusHandler = function() {
        _this.handleFocus();
      };
      _this.blurHandler = function() {
        _this.handleBlur();
      };
      _this.resizeHandler = function() {
        _this.layout();
      };
      return _this;
    }
    Object.defineProperty(MDCRippleFoundation2, "cssClasses", {
      get: function() {
        return cssClasses;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCRippleFoundation2, "strings", {
      get: function() {
        return strings;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCRippleFoundation2, "numbers", {
      get: function() {
        return numbers;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCRippleFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          browserSupportsCssVars: function() {
            return true;
          },
          computeBoundingRect: function() {
            return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
          },
          containsEventTarget: function() {
            return true;
          },
          deregisterDocumentInteractionHandler: function() {
            return void 0;
          },
          deregisterInteractionHandler: function() {
            return void 0;
          },
          deregisterResizeHandler: function() {
            return void 0;
          },
          getWindowPageOffset: function() {
            return { x: 0, y: 0 };
          },
          isSurfaceActive: function() {
            return true;
          },
          isSurfaceDisabled: function() {
            return true;
          },
          isUnbounded: function() {
            return true;
          },
          registerDocumentInteractionHandler: function() {
            return void 0;
          },
          registerInteractionHandler: function() {
            return void 0;
          },
          registerResizeHandler: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          updateCssVariable: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCRippleFoundation2.prototype.init = function() {
      var _this = this;
      var supportsPressRipple = this.supportsPressRipple();
      this.registerRootHandlers(supportsPressRipple);
      if (supportsPressRipple) {
        var _a = MDCRippleFoundation2.cssClasses, ROOT_1 = _a.ROOT, UNBOUNDED_1 = _a.UNBOUNDED;
        requestAnimationFrame(function() {
          _this.adapter.addClass(ROOT_1);
          if (_this.adapter.isUnbounded()) {
            _this.adapter.addClass(UNBOUNDED_1);
            _this.layoutInternal();
          }
        });
      }
    };
    MDCRippleFoundation2.prototype.destroy = function() {
      var _this = this;
      if (this.supportsPressRipple()) {
        if (this.activationTimer) {
          clearTimeout(this.activationTimer);
          this.activationTimer = 0;
          this.adapter.removeClass(MDCRippleFoundation2.cssClasses.FG_ACTIVATION);
        }
        if (this.fgDeactivationRemovalTimer) {
          clearTimeout(this.fgDeactivationRemovalTimer);
          this.fgDeactivationRemovalTimer = 0;
          this.adapter.removeClass(MDCRippleFoundation2.cssClasses.FG_DEACTIVATION);
        }
        var _a = MDCRippleFoundation2.cssClasses, ROOT_2 = _a.ROOT, UNBOUNDED_2 = _a.UNBOUNDED;
        requestAnimationFrame(function() {
          _this.adapter.removeClass(ROOT_2);
          _this.adapter.removeClass(UNBOUNDED_2);
          _this.removeCssVars();
        });
      }
      this.deregisterRootHandlers();
      this.deregisterDeactivationHandlers();
    };
    MDCRippleFoundation2.prototype.activate = function(evt) {
      this.activateImpl(evt);
    };
    MDCRippleFoundation2.prototype.deactivate = function() {
      this.deactivateImpl();
    };
    MDCRippleFoundation2.prototype.layout = function() {
      var _this = this;
      if (this.layoutFrame) {
        cancelAnimationFrame(this.layoutFrame);
      }
      this.layoutFrame = requestAnimationFrame(function() {
        _this.layoutInternal();
        _this.layoutFrame = 0;
      });
    };
    MDCRippleFoundation2.prototype.setUnbounded = function(unbounded) {
      var UNBOUNDED = MDCRippleFoundation2.cssClasses.UNBOUNDED;
      if (unbounded) {
        this.adapter.addClass(UNBOUNDED);
      } else {
        this.adapter.removeClass(UNBOUNDED);
      }
    };
    MDCRippleFoundation2.prototype.handleFocus = function() {
      var _this = this;
      requestAnimationFrame(function() {
        return _this.adapter.addClass(MDCRippleFoundation2.cssClasses.BG_FOCUSED);
      });
    };
    MDCRippleFoundation2.prototype.handleBlur = function() {
      var _this = this;
      requestAnimationFrame(function() {
        return _this.adapter.removeClass(MDCRippleFoundation2.cssClasses.BG_FOCUSED);
      });
    };
    MDCRippleFoundation2.prototype.supportsPressRipple = function() {
      return this.adapter.browserSupportsCssVars();
    };
    MDCRippleFoundation2.prototype.defaultActivationState = function() {
      return {
        activationEvent: void 0,
        hasDeactivationUXRun: false,
        isActivated: false,
        isProgrammatic: false,
        wasActivatedByPointer: false,
        wasElementMadeActive: false
      };
    };
    MDCRippleFoundation2.prototype.registerRootHandlers = function(supportsPressRipple) {
      var e_1, _a;
      if (supportsPressRipple) {
        try {
          for (var ACTIVATION_EVENT_TYPES_1 = __values(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next(); !ACTIVATION_EVENT_TYPES_1_1.done; ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next()) {
            var evtType = ACTIVATION_EVENT_TYPES_1_1.value;
            this.adapter.registerInteractionHandler(evtType, this.activateHandler);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (ACTIVATION_EVENT_TYPES_1_1 && !ACTIVATION_EVENT_TYPES_1_1.done && (_a = ACTIVATION_EVENT_TYPES_1.return))
              _a.call(ACTIVATION_EVENT_TYPES_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        if (this.adapter.isUnbounded()) {
          this.adapter.registerResizeHandler(this.resizeHandler);
        }
      }
      this.adapter.registerInteractionHandler("focus", this.focusHandler);
      this.adapter.registerInteractionHandler("blur", this.blurHandler);
    };
    MDCRippleFoundation2.prototype.registerDeactivationHandlers = function(evt) {
      var e_2, _a;
      if (evt.type === "keydown") {
        this.adapter.registerInteractionHandler("keyup", this.deactivateHandler);
      } else {
        try {
          for (var POINTER_DEACTIVATION_EVENT_TYPES_1 = __values(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next(); !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done; POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next()) {
            var evtType = POINTER_DEACTIVATION_EVENT_TYPES_1_1.value;
            this.adapter.registerDocumentInteractionHandler(evtType, this.deactivateHandler);
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (POINTER_DEACTIVATION_EVENT_TYPES_1_1 && !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done && (_a = POINTER_DEACTIVATION_EVENT_TYPES_1.return))
              _a.call(POINTER_DEACTIVATION_EVENT_TYPES_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
    };
    MDCRippleFoundation2.prototype.deregisterRootHandlers = function() {
      var e_3, _a;
      try {
        for (var ACTIVATION_EVENT_TYPES_2 = __values(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next(); !ACTIVATION_EVENT_TYPES_2_1.done; ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next()) {
          var evtType = ACTIVATION_EVENT_TYPES_2_1.value;
          this.adapter.deregisterInteractionHandler(evtType, this.activateHandler);
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (ACTIVATION_EVENT_TYPES_2_1 && !ACTIVATION_EVENT_TYPES_2_1.done && (_a = ACTIVATION_EVENT_TYPES_2.return))
            _a.call(ACTIVATION_EVENT_TYPES_2);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      this.adapter.deregisterInteractionHandler("focus", this.focusHandler);
      this.adapter.deregisterInteractionHandler("blur", this.blurHandler);
      if (this.adapter.isUnbounded()) {
        this.adapter.deregisterResizeHandler(this.resizeHandler);
      }
    };
    MDCRippleFoundation2.prototype.deregisterDeactivationHandlers = function() {
      var e_4, _a;
      this.adapter.deregisterInteractionHandler("keyup", this.deactivateHandler);
      try {
        for (var POINTER_DEACTIVATION_EVENT_TYPES_2 = __values(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next(); !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done; POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next()) {
          var evtType = POINTER_DEACTIVATION_EVENT_TYPES_2_1.value;
          this.adapter.deregisterDocumentInteractionHandler(evtType, this.deactivateHandler);
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (POINTER_DEACTIVATION_EVENT_TYPES_2_1 && !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done && (_a = POINTER_DEACTIVATION_EVENT_TYPES_2.return))
            _a.call(POINTER_DEACTIVATION_EVENT_TYPES_2);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
    };
    MDCRippleFoundation2.prototype.removeCssVars = function() {
      var _this = this;
      var rippleStrings = MDCRippleFoundation2.strings;
      var keys = Object.keys(rippleStrings);
      keys.forEach(function(key) {
        if (key.indexOf("VAR_") === 0) {
          _this.adapter.updateCssVariable(rippleStrings[key], null);
        }
      });
    };
    MDCRippleFoundation2.prototype.activateImpl = function(evt) {
      var _this = this;
      if (this.adapter.isSurfaceDisabled()) {
        return;
      }
      var activationState = this.activationState;
      if (activationState.isActivated) {
        return;
      }
      var previousActivationEvent = this.previousActivationEvent;
      var isSameInteraction = previousActivationEvent && evt !== void 0 && previousActivationEvent.type !== evt.type;
      if (isSameInteraction) {
        return;
      }
      activationState.isActivated = true;
      activationState.isProgrammatic = evt === void 0;
      activationState.activationEvent = evt;
      activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== void 0 && (evt.type === "mousedown" || evt.type === "touchstart" || evt.type === "pointerdown");
      var hasActivatedChild = evt !== void 0 && activatedTargets.length > 0 && activatedTargets.some(function(target) {
        return _this.adapter.containsEventTarget(target);
      });
      if (hasActivatedChild) {
        this.resetActivationState();
        return;
      }
      if (evt !== void 0) {
        activatedTargets.push(evt.target);
        this.registerDeactivationHandlers(evt);
      }
      activationState.wasElementMadeActive = this.checkElementMadeActive(evt);
      if (activationState.wasElementMadeActive) {
        this.animateActivation();
      }
      requestAnimationFrame(function() {
        activatedTargets = [];
        if (!activationState.wasElementMadeActive && evt !== void 0 && (evt.key === " " || evt.keyCode === 32)) {
          activationState.wasElementMadeActive = _this.checkElementMadeActive(evt);
          if (activationState.wasElementMadeActive) {
            _this.animateActivation();
          }
        }
        if (!activationState.wasElementMadeActive) {
          _this.activationState = _this.defaultActivationState();
        }
      });
    };
    MDCRippleFoundation2.prototype.checkElementMadeActive = function(evt) {
      return evt !== void 0 && evt.type === "keydown" ? this.adapter.isSurfaceActive() : true;
    };
    MDCRippleFoundation2.prototype.animateActivation = function() {
      var _this = this;
      var _a = MDCRippleFoundation2.strings, VAR_FG_TRANSLATE_START = _a.VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END = _a.VAR_FG_TRANSLATE_END;
      var _b = MDCRippleFoundation2.cssClasses, FG_DEACTIVATION = _b.FG_DEACTIVATION, FG_ACTIVATION = _b.FG_ACTIVATION;
      var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation2.numbers.DEACTIVATION_TIMEOUT_MS;
      this.layoutInternal();
      var translateStart = "";
      var translateEnd = "";
      if (!this.adapter.isUnbounded()) {
        var _c = this.getFgTranslationCoordinates(), startPoint = _c.startPoint, endPoint = _c.endPoint;
        translateStart = startPoint.x + "px, " + startPoint.y + "px";
        translateEnd = endPoint.x + "px, " + endPoint.y + "px";
      }
      this.adapter.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
      this.adapter.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
      clearTimeout(this.activationTimer);
      clearTimeout(this.fgDeactivationRemovalTimer);
      this.rmBoundedActivationClasses();
      this.adapter.removeClass(FG_DEACTIVATION);
      this.adapter.computeBoundingRect();
      this.adapter.addClass(FG_ACTIVATION);
      this.activationTimer = setTimeout(function() {
        _this.activationTimerCallback();
      }, DEACTIVATION_TIMEOUT_MS);
    };
    MDCRippleFoundation2.prototype.getFgTranslationCoordinates = function() {
      var _a = this.activationState, activationEvent = _a.activationEvent, wasActivatedByPointer = _a.wasActivatedByPointer;
      var startPoint;
      if (wasActivatedByPointer) {
        startPoint = getNormalizedEventCoords(activationEvent, this.adapter.getWindowPageOffset(), this.adapter.computeBoundingRect());
      } else {
        startPoint = {
          x: this.frame.width / 2,
          y: this.frame.height / 2
        };
      }
      startPoint = {
        x: startPoint.x - this.initialSize / 2,
        y: startPoint.y - this.initialSize / 2
      };
      var endPoint = {
        x: this.frame.width / 2 - this.initialSize / 2,
        y: this.frame.height / 2 - this.initialSize / 2
      };
      return { startPoint, endPoint };
    };
    MDCRippleFoundation2.prototype.runDeactivationUXLogicIfReady = function() {
      var _this = this;
      var FG_DEACTIVATION = MDCRippleFoundation2.cssClasses.FG_DEACTIVATION;
      var _a = this.activationState, hasDeactivationUXRun = _a.hasDeactivationUXRun, isActivated = _a.isActivated;
      var activationHasEnded = hasDeactivationUXRun || !isActivated;
      if (activationHasEnded && this.activationAnimationHasEnded) {
        this.rmBoundedActivationClasses();
        this.adapter.addClass(FG_DEACTIVATION);
        this.fgDeactivationRemovalTimer = setTimeout(function() {
          _this.adapter.removeClass(FG_DEACTIVATION);
        }, numbers.FG_DEACTIVATION_MS);
      }
    };
    MDCRippleFoundation2.prototype.rmBoundedActivationClasses = function() {
      var FG_ACTIVATION = MDCRippleFoundation2.cssClasses.FG_ACTIVATION;
      this.adapter.removeClass(FG_ACTIVATION);
      this.activationAnimationHasEnded = false;
      this.adapter.computeBoundingRect();
    };
    MDCRippleFoundation2.prototype.resetActivationState = function() {
      var _this = this;
      this.previousActivationEvent = this.activationState.activationEvent;
      this.activationState = this.defaultActivationState();
      setTimeout(function() {
        return _this.previousActivationEvent = void 0;
      }, MDCRippleFoundation2.numbers.TAP_DELAY_MS);
    };
    MDCRippleFoundation2.prototype.deactivateImpl = function() {
      var _this = this;
      var activationState = this.activationState;
      if (!activationState.isActivated) {
        return;
      }
      var state = __assign({}, activationState);
      if (activationState.isProgrammatic) {
        requestAnimationFrame(function() {
          _this.animateDeactivation(state);
        });
        this.resetActivationState();
      } else {
        this.deregisterDeactivationHandlers();
        requestAnimationFrame(function() {
          _this.activationState.hasDeactivationUXRun = true;
          _this.animateDeactivation(state);
          _this.resetActivationState();
        });
      }
    };
    MDCRippleFoundation2.prototype.animateDeactivation = function(_a) {
      var wasActivatedByPointer = _a.wasActivatedByPointer, wasElementMadeActive = _a.wasElementMadeActive;
      if (wasActivatedByPointer || wasElementMadeActive) {
        this.runDeactivationUXLogicIfReady();
      }
    };
    MDCRippleFoundation2.prototype.layoutInternal = function() {
      var _this = this;
      this.frame = this.adapter.computeBoundingRect();
      var maxDim = Math.max(this.frame.height, this.frame.width);
      var getBoundedRadius = function() {
        var hypotenuse = Math.sqrt(Math.pow(_this.frame.width, 2) + Math.pow(_this.frame.height, 2));
        return hypotenuse + MDCRippleFoundation2.numbers.PADDING;
      };
      this.maxRadius = this.adapter.isUnbounded() ? maxDim : getBoundedRadius();
      var initialSize = Math.floor(maxDim * MDCRippleFoundation2.numbers.INITIAL_ORIGIN_SCALE);
      if (this.adapter.isUnbounded() && initialSize % 2 !== 0) {
        this.initialSize = initialSize - 1;
      } else {
        this.initialSize = initialSize;
      }
      this.fgScale = "" + this.maxRadius / this.initialSize;
      this.updateLayoutCssVars();
    };
    MDCRippleFoundation2.prototype.updateLayoutCssVars = function() {
      var _a = MDCRippleFoundation2.strings, VAR_FG_SIZE = _a.VAR_FG_SIZE, VAR_LEFT = _a.VAR_LEFT, VAR_TOP = _a.VAR_TOP, VAR_FG_SCALE = _a.VAR_FG_SCALE;
      this.adapter.updateCssVariable(VAR_FG_SIZE, this.initialSize + "px");
      this.adapter.updateCssVariable(VAR_FG_SCALE, this.fgScale);
      if (this.adapter.isUnbounded()) {
        this.unboundedCoords = {
          left: Math.round(this.frame.width / 2 - this.initialSize / 2),
          top: Math.round(this.frame.height / 2 - this.initialSize / 2)
        };
        this.adapter.updateCssVariable(VAR_LEFT, this.unboundedCoords.left + "px");
        this.adapter.updateCssVariable(VAR_TOP, this.unboundedCoords.top + "px");
      }
    };
    return MDCRippleFoundation2;
  }(MDCFoundation)
);

// node_modules/@material/ripple/component.js
var MDCRipple = (
  /** @class */
  function(_super) {
    __extends(MDCRipple2, _super);
    function MDCRipple2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.disabled = false;
      return _this;
    }
    MDCRipple2.attachTo = function(root, opts) {
      if (opts === void 0) {
        opts = {
          isUnbounded: void 0
        };
      }
      var ripple = new MDCRipple2(root);
      if (opts.isUnbounded !== void 0) {
        ripple.unbounded = opts.isUnbounded;
      }
      return ripple;
    };
    MDCRipple2.createAdapter = function(instance3) {
      return {
        addClass: function(className) {
          return instance3.root.classList.add(className);
        },
        browserSupportsCssVars: function() {
          return supportsCssVariables(window);
        },
        computeBoundingRect: function() {
          return instance3.root.getBoundingClientRect();
        },
        containsEventTarget: function(target) {
          return instance3.root.contains(target);
        },
        deregisterDocumentInteractionHandler: function(evtType, handler) {
          return document.documentElement.removeEventListener(evtType, handler, applyPassive());
        },
        deregisterInteractionHandler: function(evtType, handler) {
          return instance3.root.removeEventListener(evtType, handler, applyPassive());
        },
        deregisterResizeHandler: function(handler) {
          return window.removeEventListener("resize", handler);
        },
        getWindowPageOffset: function() {
          return { x: window.pageXOffset, y: window.pageYOffset };
        },
        isSurfaceActive: function() {
          return matches(instance3.root, ":active");
        },
        isSurfaceDisabled: function() {
          return Boolean(instance3.disabled);
        },
        isUnbounded: function() {
          return Boolean(instance3.unbounded);
        },
        registerDocumentInteractionHandler: function(evtType, handler) {
          return document.documentElement.addEventListener(evtType, handler, applyPassive());
        },
        registerInteractionHandler: function(evtType, handler) {
          return instance3.root.addEventListener(evtType, handler, applyPassive());
        },
        registerResizeHandler: function(handler) {
          return window.addEventListener("resize", handler);
        },
        removeClass: function(className) {
          return instance3.root.classList.remove(className);
        },
        updateCssVariable: function(varName, value) {
          return instance3.root.style.setProperty(varName, value);
        }
      };
    };
    Object.defineProperty(MDCRipple2.prototype, "unbounded", {
      get: function() {
        return Boolean(this.isUnbounded);
      },
      set: function(unbounded) {
        this.isUnbounded = Boolean(unbounded);
        this.setUnbounded();
      },
      enumerable: false,
      configurable: true
    });
    MDCRipple2.prototype.activate = function() {
      this.foundation.activate();
    };
    MDCRipple2.prototype.deactivate = function() {
      this.foundation.deactivate();
    };
    MDCRipple2.prototype.layout = function() {
      this.foundation.layout();
    };
    MDCRipple2.prototype.getDefaultFoundation = function() {
      return new MDCRippleFoundation(MDCRipple2.createAdapter(this));
    };
    MDCRipple2.prototype.initialSyncWithDOM = function() {
      var root = this.root;
      this.isUnbounded = "mdcRippleIsUnbounded" in root.dataset;
    };
    MDCRipple2.prototype.setUnbounded = function() {
      this.foundation.setUnbounded(Boolean(this.isUnbounded));
    };
    return MDCRipple2;
  }(MDCComponent)
);

// node_modules/@material/animation/animationframe.js
var AnimationFrame = (
  /** @class */
  function() {
    function AnimationFrame2() {
      this.rafIDs = /* @__PURE__ */ new Map();
    }
    AnimationFrame2.prototype.request = function(key, callback) {
      var _this = this;
      this.cancel(key);
      var frameID = requestAnimationFrame(function(frame) {
        _this.rafIDs.delete(key);
        callback(frame);
      });
      this.rafIDs.set(key, frameID);
    };
    AnimationFrame2.prototype.cancel = function(key) {
      var rafID = this.rafIDs.get(key);
      if (rafID) {
        cancelAnimationFrame(rafID);
        this.rafIDs.delete(key);
      }
    };
    AnimationFrame2.prototype.cancelAll = function() {
      var _this = this;
      this.rafIDs.forEach(function(_, key) {
        _this.cancel(key);
      });
    };
    AnimationFrame2.prototype.getQueue = function() {
      var queue = [];
      this.rafIDs.forEach(function(_, key) {
        queue.push(key);
      });
      return queue;
    };
    return AnimationFrame2;
  }()
);

// node_modules/@material/dialog/constants.js
var cssClasses2 = {
  CLOSING: "mdc-dialog--closing",
  OPEN: "mdc-dialog--open",
  OPENING: "mdc-dialog--opening",
  SCROLLABLE: "mdc-dialog--scrollable",
  SCROLL_LOCK: "mdc-dialog-scroll-lock",
  STACKED: "mdc-dialog--stacked",
  FULLSCREEN: "mdc-dialog--fullscreen",
  // Class for showing a scroll divider on full-screen dialog header element.
  // Should only be displayed on scrollable content, when the dialog content is
  // scrolled "underneath" the header.
  SCROLL_DIVIDER_HEADER: "mdc-dialog-scroll-divider-header",
  // Class for showing a scroll divider on a full-screen dialog footer element.
  // Should only be displayed on scrolalble content, when the dialog content is
  // obscured "underneath" the footer.
  SCROLL_DIVIDER_FOOTER: "mdc-dialog-scroll-divider-footer",
  // The "surface scrim" is a scrim covering only the surface of a dialog. This
  // is used in situations where a confirmation dialog is shown over an already
  // opened full-screen dialog. On larger screen-sizes, the full-screen dialog
  // is sized as a modal and so in these situations we display a "surface scrim"
  // to prevent a "double scrim" (where the scrim from the secondary
  // confirmation dialog would overlap with the scrim from the full-screen
  // dialog).
  SURFACE_SCRIM_SHOWN: "mdc-dialog__surface-scrim--shown",
  // "Showing" animating class for the surface-scrim.
  SURFACE_SCRIM_SHOWING: "mdc-dialog__surface-scrim--showing",
  // "Hiding" animating class for the surface-scrim.
  SURFACE_SCRIM_HIDING: "mdc-dialog__surface-scrim--hiding",
  // Class to hide a dialog's scrim (used in conjunction with a surface-scrim).
  // Note that we only hide the original scrim rather than removing it entirely
  // to prevent interactions with the content behind this scrim, and to capture
  // scrim clicks.
  SCRIM_HIDDEN: "mdc-dialog__scrim--hidden"
};
var strings2 = {
  ACTION_ATTRIBUTE: "data-mdc-dialog-action",
  BUTTON_DEFAULT_ATTRIBUTE: "data-mdc-dialog-button-default",
  BUTTON_SELECTOR: ".mdc-dialog__button",
  CLOSED_EVENT: "MDCDialog:closed",
  CLOSE_ACTION: "close",
  CLOSING_EVENT: "MDCDialog:closing",
  CONTAINER_SELECTOR: ".mdc-dialog__container",
  CONTENT_SELECTOR: ".mdc-dialog__content",
  DESTROY_ACTION: "destroy",
  INITIAL_FOCUS_ATTRIBUTE: "data-mdc-dialog-initial-focus",
  OPENED_EVENT: "MDCDialog:opened",
  OPENING_EVENT: "MDCDialog:opening",
  SCRIM_SELECTOR: ".mdc-dialog__scrim",
  SUPPRESS_DEFAULT_PRESS_SELECTOR: [
    "textarea",
    ".mdc-menu .mdc-list-item",
    ".mdc-menu .mdc-deprecated-list-item"
  ].join(", "),
  SURFACE_SELECTOR: ".mdc-dialog__surface"
};
var numbers2 = {
  DIALOG_ANIMATION_CLOSE_TIME_MS: 75,
  DIALOG_ANIMATION_OPEN_TIME_MS: 150
};

// node_modules/@material/dialog/foundation.js
var AnimationKeys;
(function(AnimationKeys2) {
  AnimationKeys2["POLL_SCROLL_POS"] = "poll_scroll_position";
  AnimationKeys2["POLL_LAYOUT_CHANGE"] = "poll_layout_change";
})(AnimationKeys || (AnimationKeys = {}));
var MDCDialogFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCDialogFoundation2, _super);
    function MDCDialogFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCDialogFoundation2.defaultAdapter), adapter)) || this;
      _this.dialogOpen = false;
      _this.isFullscreen = false;
      _this.animationFrame = 0;
      _this.animationTimer = 0;
      _this.escapeKeyAction = strings2.CLOSE_ACTION;
      _this.scrimClickAction = strings2.CLOSE_ACTION;
      _this.autoStackButtons = true;
      _this.areButtonsStacked = false;
      _this.suppressDefaultPressSelector = strings2.SUPPRESS_DEFAULT_PRESS_SELECTOR;
      _this.animFrame = new AnimationFrame();
      _this.contentScrollHandler = function() {
        _this.handleScrollEvent();
      };
      _this.windowResizeHandler = function() {
        _this.layout();
      };
      _this.windowOrientationChangeHandler = function() {
        _this.layout();
      };
      return _this;
    }
    Object.defineProperty(MDCDialogFoundation2, "cssClasses", {
      get: function() {
        return cssClasses2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCDialogFoundation2, "strings", {
      get: function() {
        return strings2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCDialogFoundation2, "numbers", {
      get: function() {
        return numbers2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCDialogFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addBodyClass: function() {
            return void 0;
          },
          addClass: function() {
            return void 0;
          },
          areButtonsStacked: function() {
            return false;
          },
          clickDefaultButton: function() {
            return void 0;
          },
          eventTargetMatches: function() {
            return false;
          },
          getActionFromEvent: function() {
            return "";
          },
          getInitialFocusEl: function() {
            return null;
          },
          hasClass: function() {
            return false;
          },
          isContentScrollable: function() {
            return false;
          },
          notifyClosed: function() {
            return void 0;
          },
          notifyClosing: function() {
            return void 0;
          },
          notifyOpened: function() {
            return void 0;
          },
          notifyOpening: function() {
            return void 0;
          },
          releaseFocus: function() {
            return void 0;
          },
          removeBodyClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          reverseButtons: function() {
            return void 0;
          },
          trapFocus: function() {
            return void 0;
          },
          registerContentEventHandler: function() {
            return void 0;
          },
          deregisterContentEventHandler: function() {
            return void 0;
          },
          isScrollableContentAtTop: function() {
            return false;
          },
          isScrollableContentAtBottom: function() {
            return false;
          },
          registerWindowEventHandler: function() {
            return void 0;
          },
          deregisterWindowEventHandler: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCDialogFoundation2.prototype.init = function() {
      if (this.adapter.hasClass(cssClasses2.STACKED)) {
        this.setAutoStackButtons(false);
      }
      this.isFullscreen = this.adapter.hasClass(cssClasses2.FULLSCREEN);
    };
    MDCDialogFoundation2.prototype.destroy = function() {
      if (this.animationTimer) {
        clearTimeout(this.animationTimer);
        this.handleAnimationTimerEnd();
      }
      if (this.isFullscreen) {
        this.adapter.deregisterContentEventHandler("scroll", this.contentScrollHandler);
      }
      this.animFrame.cancelAll();
      this.adapter.deregisterWindowEventHandler("resize", this.windowResizeHandler);
      this.adapter.deregisterWindowEventHandler("orientationchange", this.windowOrientationChangeHandler);
    };
    MDCDialogFoundation2.prototype.open = function(dialogOptions) {
      var _this = this;
      this.dialogOpen = true;
      this.adapter.notifyOpening();
      this.adapter.addClass(cssClasses2.OPENING);
      if (this.isFullscreen) {
        this.adapter.registerContentEventHandler("scroll", this.contentScrollHandler);
      }
      if (dialogOptions && dialogOptions.isAboveFullscreenDialog) {
        this.adapter.addClass(cssClasses2.SCRIM_HIDDEN);
      }
      this.adapter.registerWindowEventHandler("resize", this.windowResizeHandler);
      this.adapter.registerWindowEventHandler("orientationchange", this.windowOrientationChangeHandler);
      this.runNextAnimationFrame(function() {
        _this.adapter.addClass(cssClasses2.OPEN);
        _this.adapter.addBodyClass(cssClasses2.SCROLL_LOCK);
        _this.layout();
        _this.animationTimer = setTimeout(function() {
          _this.handleAnimationTimerEnd();
          _this.adapter.trapFocus(_this.adapter.getInitialFocusEl());
          _this.adapter.notifyOpened();
        }, numbers2.DIALOG_ANIMATION_OPEN_TIME_MS);
      });
    };
    MDCDialogFoundation2.prototype.close = function(action) {
      var _this = this;
      if (action === void 0) {
        action = "";
      }
      if (!this.dialogOpen) {
        return;
      }
      this.dialogOpen = false;
      this.adapter.notifyClosing(action);
      this.adapter.addClass(cssClasses2.CLOSING);
      this.adapter.removeClass(cssClasses2.OPEN);
      this.adapter.removeBodyClass(cssClasses2.SCROLL_LOCK);
      if (this.isFullscreen) {
        this.adapter.deregisterContentEventHandler("scroll", this.contentScrollHandler);
      }
      this.adapter.deregisterWindowEventHandler("resize", this.windowResizeHandler);
      this.adapter.deregisterWindowEventHandler("orientationchange", this.windowOrientationChangeHandler);
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = 0;
      clearTimeout(this.animationTimer);
      this.animationTimer = setTimeout(function() {
        _this.adapter.releaseFocus();
        _this.handleAnimationTimerEnd();
        _this.adapter.notifyClosed(action);
      }, numbers2.DIALOG_ANIMATION_CLOSE_TIME_MS);
    };
    MDCDialogFoundation2.prototype.showSurfaceScrim = function() {
      var _this = this;
      this.adapter.addClass(cssClasses2.SURFACE_SCRIM_SHOWING);
      this.runNextAnimationFrame(function() {
        _this.adapter.addClass(cssClasses2.SURFACE_SCRIM_SHOWN);
      });
    };
    MDCDialogFoundation2.prototype.hideSurfaceScrim = function() {
      this.adapter.removeClass(cssClasses2.SURFACE_SCRIM_SHOWN);
      this.adapter.addClass(cssClasses2.SURFACE_SCRIM_HIDING);
    };
    MDCDialogFoundation2.prototype.handleSurfaceScrimTransitionEnd = function() {
      this.adapter.removeClass(cssClasses2.SURFACE_SCRIM_HIDING);
      this.adapter.removeClass(cssClasses2.SURFACE_SCRIM_SHOWING);
    };
    MDCDialogFoundation2.prototype.isOpen = function() {
      return this.dialogOpen;
    };
    MDCDialogFoundation2.prototype.getEscapeKeyAction = function() {
      return this.escapeKeyAction;
    };
    MDCDialogFoundation2.prototype.setEscapeKeyAction = function(action) {
      this.escapeKeyAction = action;
    };
    MDCDialogFoundation2.prototype.getScrimClickAction = function() {
      return this.scrimClickAction;
    };
    MDCDialogFoundation2.prototype.setScrimClickAction = function(action) {
      this.scrimClickAction = action;
    };
    MDCDialogFoundation2.prototype.getAutoStackButtons = function() {
      return this.autoStackButtons;
    };
    MDCDialogFoundation2.prototype.setAutoStackButtons = function(autoStack) {
      this.autoStackButtons = autoStack;
    };
    MDCDialogFoundation2.prototype.getSuppressDefaultPressSelector = function() {
      return this.suppressDefaultPressSelector;
    };
    MDCDialogFoundation2.prototype.setSuppressDefaultPressSelector = function(selector) {
      this.suppressDefaultPressSelector = selector;
    };
    MDCDialogFoundation2.prototype.layout = function() {
      var _this = this;
      this.animFrame.request(AnimationKeys.POLL_LAYOUT_CHANGE, function() {
        _this.layoutInternal();
      });
    };
    MDCDialogFoundation2.prototype.handleClick = function(evt) {
      var isScrim = this.adapter.eventTargetMatches(evt.target, strings2.SCRIM_SELECTOR);
      if (isScrim && this.scrimClickAction !== "") {
        this.close(this.scrimClickAction);
      } else {
        var action = this.adapter.getActionFromEvent(evt);
        if (action) {
          this.close(action);
        }
      }
    };
    MDCDialogFoundation2.prototype.handleKeydown = function(evt) {
      var isEnter = evt.key === "Enter" || evt.keyCode === 13;
      if (!isEnter) {
        return;
      }
      var action = this.adapter.getActionFromEvent(evt);
      if (action) {
        return;
      }
      var target = evt.composedPath ? evt.composedPath()[0] : evt.target;
      var isDefault = this.suppressDefaultPressSelector ? !this.adapter.eventTargetMatches(target, this.suppressDefaultPressSelector) : true;
      if (isEnter && isDefault) {
        this.adapter.clickDefaultButton();
      }
    };
    MDCDialogFoundation2.prototype.handleDocumentKeydown = function(evt) {
      var isEscape = evt.key === "Escape" || evt.keyCode === 27;
      if (isEscape && this.escapeKeyAction !== "") {
        this.close(this.escapeKeyAction);
      }
    };
    MDCDialogFoundation2.prototype.handleScrollEvent = function() {
      var _this = this;
      this.animFrame.request(AnimationKeys.POLL_SCROLL_POS, function() {
        _this.toggleScrollDividerHeader();
        _this.toggleScrollDividerFooter();
      });
    };
    MDCDialogFoundation2.prototype.layoutInternal = function() {
      if (this.autoStackButtons) {
        this.detectStackedButtons();
      }
      this.toggleScrollableClasses();
    };
    MDCDialogFoundation2.prototype.handleAnimationTimerEnd = function() {
      this.animationTimer = 0;
      this.adapter.removeClass(cssClasses2.OPENING);
      this.adapter.removeClass(cssClasses2.CLOSING);
    };
    MDCDialogFoundation2.prototype.runNextAnimationFrame = function(callback) {
      var _this = this;
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = requestAnimationFrame(function() {
        _this.animationFrame = 0;
        clearTimeout(_this.animationTimer);
        _this.animationTimer = setTimeout(callback, 0);
      });
    };
    MDCDialogFoundation2.prototype.detectStackedButtons = function() {
      this.adapter.removeClass(cssClasses2.STACKED);
      var areButtonsStacked = this.adapter.areButtonsStacked();
      if (areButtonsStacked) {
        this.adapter.addClass(cssClasses2.STACKED);
      }
      if (areButtonsStacked !== this.areButtonsStacked) {
        this.adapter.reverseButtons();
        this.areButtonsStacked = areButtonsStacked;
      }
    };
    MDCDialogFoundation2.prototype.toggleScrollableClasses = function() {
      this.adapter.removeClass(cssClasses2.SCROLLABLE);
      if (this.adapter.isContentScrollable()) {
        this.adapter.addClass(cssClasses2.SCROLLABLE);
        if (this.isFullscreen) {
          this.toggleScrollDividerHeader();
          this.toggleScrollDividerFooter();
        }
      }
    };
    MDCDialogFoundation2.prototype.toggleScrollDividerHeader = function() {
      if (!this.adapter.isScrollableContentAtTop()) {
        this.adapter.addClass(cssClasses2.SCROLL_DIVIDER_HEADER);
      } else if (this.adapter.hasClass(cssClasses2.SCROLL_DIVIDER_HEADER)) {
        this.adapter.removeClass(cssClasses2.SCROLL_DIVIDER_HEADER);
      }
    };
    MDCDialogFoundation2.prototype.toggleScrollDividerFooter = function() {
      if (!this.adapter.isScrollableContentAtBottom()) {
        this.adapter.addClass(cssClasses2.SCROLL_DIVIDER_FOOTER);
      } else if (this.adapter.hasClass(cssClasses2.SCROLL_DIVIDER_FOOTER)) {
        this.adapter.removeClass(cssClasses2.SCROLL_DIVIDER_FOOTER);
      }
    };
    return MDCDialogFoundation2;
  }(MDCFoundation)
);

// node_modules/@material/dialog/component.js
var strings3 = MDCDialogFoundation.strings;
var MDCDialog = (
  /** @class */
  function(_super) {
    __extends(MDCDialog2, _super);
    function MDCDialog2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(MDCDialog2.prototype, "isOpen", {
      get: function() {
        return this.foundation.isOpen();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCDialog2.prototype, "escapeKeyAction", {
      get: function() {
        return this.foundation.getEscapeKeyAction();
      },
      set: function(action) {
        this.foundation.setEscapeKeyAction(action);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCDialog2.prototype, "scrimClickAction", {
      get: function() {
        return this.foundation.getScrimClickAction();
      },
      set: function(action) {
        this.foundation.setScrimClickAction(action);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCDialog2.prototype, "autoStackButtons", {
      get: function() {
        return this.foundation.getAutoStackButtons();
      },
      set: function(autoStack) {
        this.foundation.setAutoStackButtons(autoStack);
      },
      enumerable: false,
      configurable: true
    });
    MDCDialog2.attachTo = function(root) {
      return new MDCDialog2(root);
    };
    MDCDialog2.prototype.initialize = function(focusTrapFactory) {
      var e_1, _a;
      if (focusTrapFactory === void 0) {
        focusTrapFactory = function(el, focusOptions) {
          return new FocusTrap(el, focusOptions);
        };
      }
      var container = this.root.querySelector(strings3.CONTAINER_SELECTOR);
      if (!container) {
        throw new Error("Dialog component requires a " + strings3.CONTAINER_SELECTOR + " container element");
      }
      this.container = container;
      this.content = this.root.querySelector(strings3.CONTENT_SELECTOR);
      this.buttons = [].slice.call(this.root.querySelectorAll(strings3.BUTTON_SELECTOR));
      this.defaultButton = this.root.querySelector("[" + strings3.BUTTON_DEFAULT_ATTRIBUTE + "]");
      this.focusTrapFactory = focusTrapFactory;
      this.buttonRipples = [];
      try {
        for (var _b = __values(this.buttons), _c = _b.next(); !_c.done; _c = _b.next()) {
          var buttonEl = _c.value;
          this.buttonRipples.push(new MDCRipple(buttonEl));
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    MDCDialog2.prototype.initialSyncWithDOM = function() {
      var _this = this;
      this.focusTrap = createFocusTrapInstance(this.container, this.focusTrapFactory, this.getInitialFocusEl() || void 0);
      this.handleClick = this.foundation.handleClick.bind(this.foundation);
      this.handleKeydown = this.foundation.handleKeydown.bind(this.foundation);
      this.handleDocumentKeydown = this.foundation.handleDocumentKeydown.bind(this.foundation);
      this.handleOpening = function() {
        document.addEventListener("keydown", _this.handleDocumentKeydown);
      };
      this.handleClosing = function() {
        document.removeEventListener("keydown", _this.handleDocumentKeydown);
      };
      this.listen("click", this.handleClick);
      this.listen("keydown", this.handleKeydown);
      this.listen(strings3.OPENING_EVENT, this.handleOpening);
      this.listen(strings3.CLOSING_EVENT, this.handleClosing);
    };
    MDCDialog2.prototype.destroy = function() {
      this.unlisten("click", this.handleClick);
      this.unlisten("keydown", this.handleKeydown);
      this.unlisten(strings3.OPENING_EVENT, this.handleOpening);
      this.unlisten(strings3.CLOSING_EVENT, this.handleClosing);
      this.handleClosing();
      this.buttonRipples.forEach(function(ripple) {
        ripple.destroy();
      });
      _super.prototype.destroy.call(this);
    };
    MDCDialog2.prototype.layout = function() {
      this.foundation.layout();
    };
    MDCDialog2.prototype.open = function() {
      this.foundation.open();
    };
    MDCDialog2.prototype.close = function(action) {
      if (action === void 0) {
        action = "";
      }
      this.foundation.close(action);
    };
    MDCDialog2.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        addBodyClass: function(className) {
          return document.body.classList.add(className);
        },
        addClass: function(className) {
          return _this.root.classList.add(className);
        },
        areButtonsStacked: function() {
          return areTopsMisaligned(_this.buttons);
        },
        clickDefaultButton: function() {
          if (_this.defaultButton && !_this.defaultButton.disabled) {
            _this.defaultButton.click();
          }
        },
        eventTargetMatches: function(target, selector) {
          return target ? matches(target, selector) : false;
        },
        getActionFromEvent: function(evt) {
          if (!evt.target) {
            return "";
          }
          var element2 = closest(evt.target, "[" + strings3.ACTION_ATTRIBUTE + "]");
          return element2 && element2.getAttribute(strings3.ACTION_ATTRIBUTE);
        },
        getInitialFocusEl: function() {
          return _this.getInitialFocusEl();
        },
        hasClass: function(className) {
          return _this.root.classList.contains(className);
        },
        isContentScrollable: function() {
          return isScrollable(_this.content);
        },
        notifyClosed: function(action) {
          return _this.emit(strings3.CLOSED_EVENT, action ? { action } : {});
        },
        notifyClosing: function(action) {
          return _this.emit(strings3.CLOSING_EVENT, action ? { action } : {});
        },
        notifyOpened: function() {
          return _this.emit(strings3.OPENED_EVENT, {});
        },
        notifyOpening: function() {
          return _this.emit(strings3.OPENING_EVENT, {});
        },
        releaseFocus: function() {
          _this.focusTrap.releaseFocus();
        },
        removeBodyClass: function(className) {
          return document.body.classList.remove(className);
        },
        removeClass: function(className) {
          return _this.root.classList.remove(className);
        },
        reverseButtons: function() {
          _this.buttons.reverse();
          _this.buttons.forEach(function(button) {
            button.parentElement.appendChild(button);
          });
        },
        trapFocus: function() {
          _this.focusTrap.trapFocus();
        },
        registerContentEventHandler: function(evt, handler) {
          if (_this.content instanceof HTMLElement) {
            _this.content.addEventListener(evt, handler);
          }
        },
        deregisterContentEventHandler: function(evt, handler) {
          if (_this.content instanceof HTMLElement) {
            _this.content.removeEventListener(evt, handler);
          }
        },
        isScrollableContentAtTop: function() {
          return isScrollAtTop(_this.content);
        },
        isScrollableContentAtBottom: function() {
          return isScrollAtBottom(_this.content);
        },
        registerWindowEventHandler: function(evt, handler) {
          window.addEventListener(evt, handler);
        },
        deregisterWindowEventHandler: function(evt, handler) {
          window.removeEventListener(evt, handler);
        }
      };
      return new MDCDialogFoundation(adapter);
    };
    MDCDialog2.prototype.getInitialFocusEl = function() {
      return this.root.querySelector("[" + strings3.INITIAL_FOCUS_ATTRIBUTE + "]");
    };
    return MDCDialog2;
  }(MDCComponent)
);

// node_modules/@material/dom/keyboard.js
var KEY = {
  UNKNOWN: "Unknown",
  BACKSPACE: "Backspace",
  ENTER: "Enter",
  SPACEBAR: "Spacebar",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown",
  END: "End",
  HOME: "Home",
  ARROW_LEFT: "ArrowLeft",
  ARROW_UP: "ArrowUp",
  ARROW_RIGHT: "ArrowRight",
  ARROW_DOWN: "ArrowDown",
  DELETE: "Delete",
  ESCAPE: "Escape",
  TAB: "Tab"
};
var normalizedKeys = /* @__PURE__ */ new Set();
normalizedKeys.add(KEY.BACKSPACE);
normalizedKeys.add(KEY.ENTER);
normalizedKeys.add(KEY.SPACEBAR);
normalizedKeys.add(KEY.PAGE_UP);
normalizedKeys.add(KEY.PAGE_DOWN);
normalizedKeys.add(KEY.END);
normalizedKeys.add(KEY.HOME);
normalizedKeys.add(KEY.ARROW_LEFT);
normalizedKeys.add(KEY.ARROW_UP);
normalizedKeys.add(KEY.ARROW_RIGHT);
normalizedKeys.add(KEY.ARROW_DOWN);
normalizedKeys.add(KEY.DELETE);
normalizedKeys.add(KEY.ESCAPE);
normalizedKeys.add(KEY.TAB);
var KEY_CODE = {
  BACKSPACE: 8,
  ENTER: 13,
  SPACEBAR: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  ARROW_LEFT: 37,
  ARROW_UP: 38,
  ARROW_RIGHT: 39,
  ARROW_DOWN: 40,
  DELETE: 46,
  ESCAPE: 27,
  TAB: 9
};
var mappedKeyCodes = /* @__PURE__ */ new Map();
mappedKeyCodes.set(KEY_CODE.BACKSPACE, KEY.BACKSPACE);
mappedKeyCodes.set(KEY_CODE.ENTER, KEY.ENTER);
mappedKeyCodes.set(KEY_CODE.SPACEBAR, KEY.SPACEBAR);
mappedKeyCodes.set(KEY_CODE.PAGE_UP, KEY.PAGE_UP);
mappedKeyCodes.set(KEY_CODE.PAGE_DOWN, KEY.PAGE_DOWN);
mappedKeyCodes.set(KEY_CODE.END, KEY.END);
mappedKeyCodes.set(KEY_CODE.HOME, KEY.HOME);
mappedKeyCodes.set(KEY_CODE.ARROW_LEFT, KEY.ARROW_LEFT);
mappedKeyCodes.set(KEY_CODE.ARROW_UP, KEY.ARROW_UP);
mappedKeyCodes.set(KEY_CODE.ARROW_RIGHT, KEY.ARROW_RIGHT);
mappedKeyCodes.set(KEY_CODE.ARROW_DOWN, KEY.ARROW_DOWN);
mappedKeyCodes.set(KEY_CODE.DELETE, KEY.DELETE);
mappedKeyCodes.set(KEY_CODE.ESCAPE, KEY.ESCAPE);
mappedKeyCodes.set(KEY_CODE.TAB, KEY.TAB);
var navigationKeys = /* @__PURE__ */ new Set();
navigationKeys.add(KEY.PAGE_UP);
navigationKeys.add(KEY.PAGE_DOWN);
navigationKeys.add(KEY.END);
navigationKeys.add(KEY.HOME);
navigationKeys.add(KEY.ARROW_LEFT);
navigationKeys.add(KEY.ARROW_UP);
navigationKeys.add(KEY.ARROW_RIGHT);
navigationKeys.add(KEY.ARROW_DOWN);

// node_modules/@smui/common/dist/internal/classMap.js
function classMap(classObj) {
  return Object.entries(classObj).filter(([name, value]) => name !== "" && value).map(([name]) => name).join(" ");
}

// node_modules/@smui/common/dist/internal/dispatch.js
function dispatch(element2, eventType, detail, eventInit = { bubbles: true }, duplicateEventForMDC = false) {
  if (typeof Event === "undefined") {
    throw new Error("Event not defined.");
  }
  if (!element2) {
    throw new Error("Tried to dipatch event without element.");
  }
  const event = new CustomEvent(eventType, Object.assign(Object.assign({}, eventInit), { detail }));
  element2 === null || element2 === void 0 ? void 0 : element2.dispatchEvent(event);
  if (duplicateEventForMDC && eventType.startsWith("SMUI")) {
    const duplicateEvent = new CustomEvent(eventType.replace(/^SMUI/g, () => "MDC"), Object.assign(Object.assign({}, eventInit), { detail }));
    element2 === null || element2 === void 0 ? void 0 : element2.dispatchEvent(duplicateEvent);
    if (duplicateEvent.defaultPrevented) {
      event.preventDefault();
    }
  }
  return event;
}

// node_modules/@smui/common/dist/internal/exclude.js
function exclude(obj, keys) {
  let names = Object.getOwnPropertyNames(obj);
  const newObj = {};
  for (let i = 0; i < names.length; i++) {
    const name = names[i];
    const cashIndex = name.indexOf("$");
    if (cashIndex !== -1 && keys.indexOf(name.substring(0, cashIndex + 1)) !== -1) {
      continue;
    }
    if (keys.indexOf(name) !== -1) {
      continue;
    }
    newObj[name] = obj[name];
  }
  return newObj;
}

// node_modules/@smui/common/dist/internal/forwardEventsBuilder.js
var oldModifierRegex = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
var newModifierRegex = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
function forwardEventsBuilder(component) {
  let $on;
  let events = [];
  component.$on = (fullEventType, callback) => {
    let eventType = fullEventType;
    let destructor = () => {
    };
    if ($on) {
      destructor = $on(eventType, callback);
    } else {
      events.push([eventType, callback]);
    }
    const oldModifierMatch = eventType.match(oldModifierRegex);
    if (oldModifierMatch && console) {
      console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', eventType);
    }
    return () => {
      destructor();
    };
  };
  function bubble(e) {
    const callbacks = component.$$.callbacks[e.type];
    if (callbacks) {
      callbacks.slice().forEach((fn) => fn.call(this, e));
    }
  }
  return (node) => {
    const destructors = [];
    const forwardDestructors = {};
    $on = (fullEventType, callback) => {
      let eventType = fullEventType;
      let handler = callback;
      let options = false;
      const oldModifierMatch = eventType.match(oldModifierRegex);
      const newModifierMatch = eventType.match(newModifierRegex);
      const modifierMatch = oldModifierMatch || newModifierMatch;
      if (eventType.match(/^SMUI:\w+:/)) {
        const newEventTypeParts = eventType.split(":");
        let newEventType = "";
        for (let i = 0; i < newEventTypeParts.length; i++) {
          newEventType += i === newEventTypeParts.length - 1 ? ":" + newEventTypeParts[i] : newEventTypeParts[i].split("-").map((value) => value.slice(0, 1).toUpperCase() + value.slice(1)).join("");
        }
        console.warn(`The event ${eventType.split("$")[0]} has been renamed to ${newEventType.split("$")[0]}.`);
        eventType = newEventType;
      }
      if (modifierMatch) {
        const parts = eventType.split(oldModifierMatch ? ":" : "$");
        eventType = parts[0];
        const eventOptions = parts.slice(1).reduce((obj, mod) => {
          obj[mod] = true;
          return obj;
        }, {});
        if (eventOptions.passive) {
          options = options || {};
          options.passive = true;
        }
        if (eventOptions.nonpassive) {
          options = options || {};
          options.passive = false;
        }
        if (eventOptions.capture) {
          options = options || {};
          options.capture = true;
        }
        if (eventOptions.once) {
          options = options || {};
          options.once = true;
        }
        if (eventOptions.preventDefault) {
          handler = prevent_default(handler);
        }
        if (eventOptions.stopPropagation) {
          handler = stop_propagation(handler);
        }
        if (eventOptions.stopImmediatePropagation) {
          handler = stop_immediate_propagation(handler);
        }
        if (eventOptions.self) {
          handler = self_event(node, handler);
        }
        if (eventOptions.trusted) {
          handler = trusted_event(handler);
        }
      }
      const off = listen(node, eventType, handler, options);
      const destructor = () => {
        off();
        const idx = destructors.indexOf(destructor);
        if (idx > -1) {
          destructors.splice(idx, 1);
        }
      };
      destructors.push(destructor);
      if (!(eventType in forwardDestructors)) {
        forwardDestructors[eventType] = listen(node, eventType, bubble);
      }
      return destructor;
    };
    for (let i = 0; i < events.length; i++) {
      $on(events[i][0], events[i][1]);
    }
    return {
      destroy: () => {
        for (let i = 0; i < destructors.length; i++) {
          destructors[i]();
        }
        for (let entry of Object.entries(forwardDestructors)) {
          entry[1]();
        }
      }
    };
  };
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function stop_propagation(fn) {
  return function(event) {
    event.stopPropagation();
    return fn.call(this, event);
  };
}
function stop_immediate_propagation(fn) {
  return function(event) {
    event.stopImmediatePropagation();
    return fn.call(this, event);
  };
}
function self_event(node, fn) {
  return function(event) {
    if (event.target !== node) {
      return;
    }
    return fn.call(this, event);
  };
}
function trusted_event(fn) {
  return function(event) {
    if (!event.isTrusted) {
      return;
    }
    return fn.call(this, event);
  };
}

// node_modules/@smui/common/dist/internal/prefixFilter.js
function prefixFilter(obj, prefix) {
  let names = Object.getOwnPropertyNames(obj);
  const newObj = {};
  for (let i = 0; i < names.length; i++) {
    const name = names[i];
    if (name.substring(0, prefix.length) === prefix) {
      newObj[name.substring(prefix.length)] = obj[name];
    }
  }
  return newObj;
}

// node_modules/@smui/common/dist/internal/useActions.js
function useActions(node, actions) {
  let actionReturns = [];
  if (actions) {
    for (let i = 0; i < actions.length; i++) {
      const actionEntry = actions[i];
      const action = Array.isArray(actionEntry) ? actionEntry[0] : actionEntry;
      if (Array.isArray(actionEntry) && actionEntry.length > 1) {
        actionReturns.push(action(node, actionEntry[1]));
      } else {
        actionReturns.push(action(node));
      }
    }
  }
  return {
    update(actions2) {
      if ((actions2 && actions2.length || 0) != actionReturns.length) {
        throw new Error("You must not change the length of an actions array.");
      }
      if (actions2) {
        for (let i = 0; i < actions2.length; i++) {
          const returnEntry = actionReturns[i];
          if (returnEntry && returnEntry.update) {
            const actionEntry = actions2[i];
            if (Array.isArray(actionEntry) && actionEntry.length > 1) {
              returnEntry.update(actionEntry[1]);
            } else {
              returnEntry.update();
            }
          }
        }
      }
    },
    destroy() {
      for (let i = 0; i < actionReturns.length; i++) {
        const returnEntry = actionReturns[i];
        if (returnEntry && returnEntry.destroy) {
          returnEntry.destroy();
        }
      }
    }
  };
}

// node_modules/@smui/dialog/dist/Dialog.svelte
var { document: document_1, window: window_1 } = globals;
var file = "node_modules/@smui/dialog/dist/Dialog.svelte";
var get_over_slot_changes = (dirty) => ({});
var get_over_slot_context = (ctx) => ({});
function create_if_block(ctx) {
  let div;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "mdc-dialog__surface-scrim");
      add_location(div, file, 49, 8, 1397);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (!mounted) {
        dispose = listen_dev(
          div,
          "transitionend",
          /*transitionend_handler*/
          ctx[32],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(49:6) {#if fullscreen}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let t0;
  let div3;
  let div1;
  let div0;
  let t1;
  let div0_class_value;
  let div1_class_value;
  let t2;
  let div2;
  let div3_class_value;
  let useActions_action;
  let forwardEvents_action;
  let t3;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[29].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    null
  );
  let if_block = (
    /*fullscreen*/
    ctx[5] && create_if_block(ctx)
  );
  let div0_levels = [
    {
      class: div0_class_value = classMap({
        [
          /*surface$class*/
          ctx[9]
        ]: true,
        "mdc-dialog__surface": true
      })
    },
    { role: "alertdialog" },
    { "aria-modal": "true" },
    prefixFilter(
      /*$$restProps*/
      ctx[19],
      "surface$"
    )
  ];
  let div_data_1 = {};
  for (let i = 0; i < div0_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div0_levels[i]);
  }
  let div1_levels = [
    {
      class: div1_class_value = classMap({
        [
          /*container$class*/
          ctx[8]
        ]: true,
        "mdc-dialog__container": true
      })
    },
    prefixFilter(
      /*$$restProps*/
      ctx[19],
      "container$"
    )
  ];
  let div_data_2 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_2 = assign(div_data_2, div1_levels[i]);
  }
  let div3_levels = [
    {
      class: div3_class_value = classMap({
        [
          /*className*/
          ctx[2]
        ]: true,
        "mdc-dialog": true,
        "mdc-dialog--stacked": !/*autoStackButtons*/
        ctx[4],
        "mdc-dialog--fullscreen": (
          /*fullscreen*/
          ctx[5]
        ),
        "mdc-dialog--sheet": (
          /*sheet*/
          ctx[6]
        ),
        "mdc-dialog--no-content-padding": (
          /*noContentPadding*/
          ctx[7]
        ),
        "smui-dialog--selection": (
          /*selection*/
          ctx[3]
        ),
        .../*internalClasses*/
        ctx[12]
      })
    },
    { role: "alertdialog" },
    { "aria-modal": "true" },
    exclude(
      /*$$restProps*/
      ctx[19],
      ["container$", "surface$"]
    )
  ];
  let div_data_3 = {};
  for (let i = 0; i < div3_levels.length; i += 1) {
    div_data_3 = assign(div_data_3, div3_levels[i]);
  }
  const over_slot_template = (
    /*#slots*/
    ctx[29].over
  );
  const over_slot = create_slot(
    over_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_over_slot_context
  );
  const block = {
    c: function create() {
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      div2 = element("div");
      t3 = space();
      if (over_slot)
        over_slot.c();
      set_attributes(div0, div_data_1);
      add_location(div0, file, 38, 4, 1140);
      set_attributes(div1, div_data_2);
      add_location(div1, file, 31, 2, 980);
      attr_dev(div2, "class", "mdc-dialog__scrim");
      add_location(div2, file, 57, 2, 1593);
      set_attributes(div3, div_data_3);
      add_location(div3, file, 8, 0, 235);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t0, anchor);
      insert_dev(target, div3, anchor);
      append_dev(div3, div1);
      append_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      append_dev(div3, t2);
      append_dev(div3, div2);
      ctx[33](div3);
      insert_dev(target, t3, anchor);
      if (over_slot) {
        over_slot.m(target, anchor);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window_1,
            "resize",
            /*resize_handler*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window_1,
            "orientationchange",
            /*orientationchange_handler*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            document_1.body,
            "keydown",
            function() {
              if (is_function(
                /*instance*/
                ctx[10] && /*instance*/
                ctx[10].handleDocumentKeydown.bind(
                  /*instance*/
                  ctx[10]
                )
              ))
                /*instance*/
                (ctx[10] && /*instance*/
                ctx[10].handleDocumentKeydown.bind(
                  /*instance*/
                  ctx[10]
                )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          action_destroyer(useActions_action = useActions.call(
            null,
            div3,
            /*use*/
            ctx[1]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[13].call(null, div3)),
          listen_dev(
            div3,
            "SMUIDialog:opening",
            /*handleDialogOpening*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "SMUIDialog:opened",
            /*handleDialogOpened*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "SMUIDialog:closed",
            /*handleDialogClosed*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "click",
            function() {
              if (is_function(
                /*instance*/
                ctx[10] && /*instance*/
                ctx[10].handleClick.bind(
                  /*instance*/
                  ctx[10]
                )
              ))
                /*instance*/
                (ctx[10] && /*instance*/
                ctx[10].handleClick.bind(
                  /*instance*/
                  ctx[10]
                )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keydown",
            function() {
              if (is_function(
                /*instance*/
                ctx[10] && /*instance*/
                ctx[10].handleKeydown.bind(
                  /*instance*/
                  ctx[10]
                )
              ))
                /*instance*/
                (ctx[10] && /*instance*/
                ctx[10].handleKeydown.bind(
                  /*instance*/
                  ctx[10]
                )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        268435456)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[28]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[28],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*fullscreen*/
        ctx[5]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block(ctx);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div0, div_data_1 = get_spread_update(div0_levels, [
        (!current || dirty[0] & /*surface$class*/
        512 && div0_class_value !== (div0_class_value = classMap({
          [
            /*surface$class*/
            ctx[9]
          ]: true,
          "mdc-dialog__surface": true
        }))) && { class: div0_class_value },
        { role: "alertdialog" },
        { "aria-modal": "true" },
        dirty[0] & /*$$restProps*/
        524288 && prefixFilter(
          /*$$restProps*/
          ctx[19],
          "surface$"
        )
      ]));
      set_attributes(div1, div_data_2 = get_spread_update(div1_levels, [
        (!current || dirty[0] & /*container$class*/
        256 && div1_class_value !== (div1_class_value = classMap({
          [
            /*container$class*/
            ctx[8]
          ]: true,
          "mdc-dialog__container": true
        }))) && { class: div1_class_value },
        dirty[0] & /*$$restProps*/
        524288 && prefixFilter(
          /*$$restProps*/
          ctx[19],
          "container$"
        )
      ]));
      set_attributes(div3, div_data_3 = get_spread_update(div3_levels, [
        (!current || dirty[0] & /*className, autoStackButtons, fullscreen, sheet, noContentPadding, selection, internalClasses*/
        4348 && div3_class_value !== (div3_class_value = classMap({
          [
            /*className*/
            ctx[2]
          ]: true,
          "mdc-dialog": true,
          "mdc-dialog--stacked": !/*autoStackButtons*/
          ctx[4],
          "mdc-dialog--fullscreen": (
            /*fullscreen*/
            ctx[5]
          ),
          "mdc-dialog--sheet": (
            /*sheet*/
            ctx[6]
          ),
          "mdc-dialog--no-content-padding": (
            /*noContentPadding*/
            ctx[7]
          ),
          "smui-dialog--selection": (
            /*selection*/
            ctx[3]
          ),
          .../*internalClasses*/
          ctx[12]
        }))) && { class: div3_class_value },
        { role: "alertdialog" },
        { "aria-modal": "true" },
        dirty[0] & /*$$restProps*/
        524288 && exclude(
          /*$$restProps*/
          ctx[19],
          ["container$", "surface$"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/
      2)
        useActions_action.update.call(
          null,
          /*use*/
          ctx[1]
        );
      if (over_slot) {
        if (over_slot.p && (!current || dirty[0] & /*$$scope*/
        268435456)) {
          update_slot_base(
            over_slot,
            over_slot_template,
            ctx,
            /*$$scope*/
            ctx[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[28]
            ) : get_slot_changes(
              over_slot_template,
              /*$$scope*/
              ctx[28],
              dirty,
              get_over_slot_changes
            ),
            get_over_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(over_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(over_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(div3);
        detach_dev(t3);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[33](null);
      if (over_slot)
        over_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "open",
    "selection",
    "escapeKeyAction",
    "scrimClickAction",
    "autoStackButtons",
    "fullscreen",
    "sheet",
    "noContentPadding",
    "container$class",
    "surface$class",
    "isOpen",
    "setOpen",
    "layout",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $aboveFullscreenShown;
  let $actionButtonsReversed;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dialog", slots, ["default", "over"]);
  var _a;
  const { FocusTrap: FocusTrap2 } = focus_trap_exports;
  const { closest: closest2, matches: matches2 } = ponyfill_exports;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { open = false } = $$props;
  let { selection = false } = $$props;
  let { escapeKeyAction = "close" } = $$props;
  let { scrimClickAction = "close" } = $$props;
  let { autoStackButtons = true } = $$props;
  let { fullscreen = false } = $$props;
  let { sheet = false } = $$props;
  let { noContentPadding = false } = $$props;
  let { container$class = "" } = $$props;
  let { surface$class = "" } = $$props;
  let element2;
  let instance3;
  let internalClasses = {};
  let focusTrap;
  let actionButtonsReversed = writable(false);
  validate_store(actionButtonsReversed, "actionButtonsReversed");
  component_subscribe($$self, actionButtonsReversed, (value) => $$invalidate(37, $actionButtonsReversed = value));
  let aboveFullscreen = getContext("SMUI:dialog:aboveFullscreen");
  let aboveFullscreenShown = (_a = getContext("SMUI:dialog:aboveFullscreenShown")) !== null && _a !== void 0 ? _a : writable(false);
  validate_store(aboveFullscreenShown, "aboveFullscreenShown");
  component_subscribe($$self, aboveFullscreenShown, (value) => $$invalidate(27, $aboveFullscreenShown = value));
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let layoutListeners = [];
  let addLayoutListenerFn = (listener) => {
    layoutListeners.push(listener);
    return () => {
      const idx = layoutListeners.indexOf(listener);
      if (idx >= 0) {
        layoutListeners.splice(idx, 1);
      }
    };
  };
  setContext("SMUI:dialog:actions:reversed", actionButtonsReversed);
  setContext("SMUI:addLayoutListener", addLayoutListenerFn);
  setContext("SMUI:dialog:selection", selection);
  setContext("SMUI:dialog:aboveFullscreen", aboveFullscreen || fullscreen);
  setContext("SMUI:dialog:aboveFullscreenShown", aboveFullscreenShown);
  if (sheet) {
    setContext("SMUI:icon-button:context", "dialog:sheet");
  }
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  let previousAboveFullscreenShown = $aboveFullscreenShown;
  onMount(() => {
    var _a2;
    focusTrap = new FocusTrap2(
      element2,
      {
        initialFocusEl: (_a2 = getInitialFocusEl()) !== null && _a2 !== void 0 ? _a2 : void 0
      }
    );
    $$invalidate(10, instance3 = new MDCDialogFoundation({
      addBodyClass: (className2) => document.body.classList.add(className2),
      addClass,
      areButtonsStacked: () => util_exports.areTopsMisaligned(getButtonEls()),
      clickDefaultButton: () => {
        const defaultButton = getDefaultButtonEl();
        if (defaultButton) {
          defaultButton.click();
        }
      },
      eventTargetMatches: (target, selector) => target ? matches2(target, selector) : false,
      getActionFromEvent: (evt) => {
        if (!evt.target) {
          return "";
        }
        const element3 = closest2(evt.target, "[data-mdc-dialog-action]");
        return element3 && element3.getAttribute("data-mdc-dialog-action");
      },
      getInitialFocusEl,
      hasClass,
      isContentScrollable: () => util_exports.isScrollable(getContentEl()),
      notifyClosed: (action) => {
        $$invalidate(0, open = false);
        dispatch(getElement(), "SMUIDialog:closed", action ? { action } : {}, void 0, true);
      },
      notifyClosing: (action) => dispatch(getElement(), "SMUIDialog:closing", action ? { action } : {}, void 0, true),
      notifyOpened: () => dispatch(getElement(), "SMUIDialog:opened", {}, void 0, true),
      notifyOpening: () => dispatch(getElement(), "SMUIDialog:opening", {}, void 0, true),
      releaseFocus: () => focusTrap.releaseFocus(),
      removeBodyClass: (className2) => document.body.classList.remove(className2),
      removeClass,
      reverseButtons: () => {
        set_store_value(actionButtonsReversed, $actionButtonsReversed = true, $actionButtonsReversed);
      },
      trapFocus: () => focusTrap.trapFocus(),
      registerContentEventHandler: (evt, handler) => {
        const content = getContentEl();
        if (content instanceof HTMLElement) {
          content.addEventListener(evt, handler);
        }
      },
      deregisterContentEventHandler: (evt, handler) => {
        const content = getContentEl();
        if (content instanceof HTMLElement) {
          content.removeEventListener(evt, handler);
        }
      },
      isScrollableContentAtTop: () => {
        return util_exports.isScrollAtTop(getContentEl());
      },
      isScrollableContentAtBottom: () => {
        return util_exports.isScrollAtBottom(getContentEl());
      },
      registerWindowEventHandler: (evt, handler) => {
        window.addEventListener(evt, handler);
      },
      deregisterWindowEventHandler: (evt, handler) => {
        window.removeEventListener(evt, handler);
      }
    }));
    instance3.init();
    return () => {
      instance3.destroy();
    };
  });
  onDestroy(() => {
    if (removeLayoutListener) {
      removeLayoutListener();
    }
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(12, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(12, internalClasses[className2] = false, internalClasses);
    }
  }
  function getButtonEls() {
    return [].slice.call(element2.querySelectorAll(".mdc-dialog__button"));
  }
  function getDefaultButtonEl() {
    return element2.querySelector("[data-mdc-dialog-button-default]");
  }
  function getContentEl() {
    return element2.querySelector(".mdc-dialog__content");
  }
  function getInitialFocusEl() {
    return element2.querySelector("[data-mdc-dialog-initial-focus]");
  }
  function handleDialogOpening() {
    if (aboveFullscreen) {
      set_store_value(aboveFullscreenShown, $aboveFullscreenShown = true, $aboveFullscreenShown);
    }
    requestAnimationFrame(() => {
      layoutListeners.forEach((listener) => listener());
    });
  }
  function handleDialogOpened() {
    layoutListeners.forEach((listener) => listener());
  }
  function handleDialogClosed() {
    if (aboveFullscreen) {
      set_store_value(aboveFullscreenShown, $aboveFullscreenShown = false, $aboveFullscreenShown);
    }
  }
  function isOpen() {
    return open;
  }
  function setOpen(value) {
    $$invalidate(0, open = value);
  }
  function layout() {
    return instance3.layout();
  }
  function getElement() {
    return element2;
  }
  const resize_handler = () => open && instance3 && instance3.layout();
  const orientationchange_handler = () => open && instance3 && instance3.layout();
  const transitionend_handler = () => instance3 && instance3.handleSurfaceScrimTransitionEnd();
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(11, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("selection" in $$new_props)
      $$invalidate(3, selection = $$new_props.selection);
    if ("escapeKeyAction" in $$new_props)
      $$invalidate(20, escapeKeyAction = $$new_props.escapeKeyAction);
    if ("scrimClickAction" in $$new_props)
      $$invalidate(21, scrimClickAction = $$new_props.scrimClickAction);
    if ("autoStackButtons" in $$new_props)
      $$invalidate(4, autoStackButtons = $$new_props.autoStackButtons);
    if ("fullscreen" in $$new_props)
      $$invalidate(5, fullscreen = $$new_props.fullscreen);
    if ("sheet" in $$new_props)
      $$invalidate(6, sheet = $$new_props.sheet);
    if ("noContentPadding" in $$new_props)
      $$invalidate(7, noContentPadding = $$new_props.noContentPadding);
    if ("container$class" in $$new_props)
      $$invalidate(8, container$class = $$new_props.container$class);
    if ("surface$class" in $$new_props)
      $$invalidate(9, surface$class = $$new_props.surface$class);
    if ("$$scope" in $$new_props)
      $$invalidate(28, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    _a,
    MDCDialogFoundation,
    util: util_exports,
    domFocusTrap: focus_trap_exports,
    ponyfill: ponyfill_exports,
    onMount,
    onDestroy,
    getContext,
    setContext,
    writable,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    exclude,
    prefixFilter,
    useActions,
    dispatch,
    FocusTrap: FocusTrap2,
    closest: closest2,
    matches: matches2,
    forwardEvents,
    use,
    className,
    open,
    selection,
    escapeKeyAction,
    scrimClickAction,
    autoStackButtons,
    fullscreen,
    sheet,
    noContentPadding,
    container$class,
    surface$class,
    element: element2,
    instance: instance3,
    internalClasses,
    focusTrap,
    actionButtonsReversed,
    aboveFullscreen,
    aboveFullscreenShown,
    addLayoutListener,
    removeLayoutListener,
    layoutListeners,
    addLayoutListenerFn,
    previousAboveFullscreenShown,
    hasClass,
    addClass,
    removeClass,
    getButtonEls,
    getDefaultButtonEl,
    getContentEl,
    getInitialFocusEl,
    handleDialogOpening,
    handleDialogOpened,
    handleDialogClosed,
    isOpen,
    setOpen,
    layout,
    getElement,
    $aboveFullscreenShown,
    $actionButtonsReversed
  });
  $$self.$inject_state = ($$new_props) => {
    if ("_a" in $$props)
      _a = $$new_props._a;
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("selection" in $$props)
      $$invalidate(3, selection = $$new_props.selection);
    if ("escapeKeyAction" in $$props)
      $$invalidate(20, escapeKeyAction = $$new_props.escapeKeyAction);
    if ("scrimClickAction" in $$props)
      $$invalidate(21, scrimClickAction = $$new_props.scrimClickAction);
    if ("autoStackButtons" in $$props)
      $$invalidate(4, autoStackButtons = $$new_props.autoStackButtons);
    if ("fullscreen" in $$props)
      $$invalidate(5, fullscreen = $$new_props.fullscreen);
    if ("sheet" in $$props)
      $$invalidate(6, sheet = $$new_props.sheet);
    if ("noContentPadding" in $$props)
      $$invalidate(7, noContentPadding = $$new_props.noContentPadding);
    if ("container$class" in $$props)
      $$invalidate(8, container$class = $$new_props.container$class);
    if ("surface$class" in $$props)
      $$invalidate(9, surface$class = $$new_props.surface$class);
    if ("element" in $$props)
      $$invalidate(11, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(10, instance3 = $$new_props.instance);
    if ("internalClasses" in $$props)
      $$invalidate(12, internalClasses = $$new_props.internalClasses);
    if ("focusTrap" in $$props)
      focusTrap = $$new_props.focusTrap;
    if ("actionButtonsReversed" in $$props)
      $$invalidate(14, actionButtonsReversed = $$new_props.actionButtonsReversed);
    if ("aboveFullscreen" in $$props)
      $$invalidate(41, aboveFullscreen = $$new_props.aboveFullscreen);
    if ("aboveFullscreenShown" in $$props)
      $$invalidate(15, aboveFullscreenShown = $$new_props.aboveFullscreenShown);
    if ("addLayoutListener" in $$props)
      addLayoutListener = $$new_props.addLayoutListener;
    if ("removeLayoutListener" in $$props)
      removeLayoutListener = $$new_props.removeLayoutListener;
    if ("layoutListeners" in $$props)
      layoutListeners = $$new_props.layoutListeners;
    if ("addLayoutListenerFn" in $$props)
      addLayoutListenerFn = $$new_props.addLayoutListenerFn;
    if ("previousAboveFullscreenShown" in $$props)
      $$invalidate(26, previousAboveFullscreenShown = $$new_props.previousAboveFullscreenShown);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*instance, escapeKeyAction*/
    1049600) {
      $:
        if (instance3 && instance3.getEscapeKeyAction() !== escapeKeyAction) {
          instance3.setEscapeKeyAction(escapeKeyAction);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, scrimClickAction*/
    2098176) {
      $:
        if (instance3 && instance3.getScrimClickAction() !== scrimClickAction) {
          instance3.setScrimClickAction(scrimClickAction);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, autoStackButtons*/
    1040) {
      $:
        if (instance3 && instance3.getAutoStackButtons() !== autoStackButtons) {
          instance3.setAutoStackButtons(autoStackButtons);
        }
    }
    if ($$self.$$.dirty[0] & /*autoStackButtons*/
    16) {
      $:
        if (!autoStackButtons) {
          set_store_value(actionButtonsReversed, $actionButtonsReversed = true, $actionButtonsReversed);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, open*/
    1025) {
      $:
        if (instance3 && instance3.isOpen() !== open) {
          if (open) {
            instance3.open({
              isAboveFullscreenDialog: !!aboveFullscreen
            });
          } else {
            instance3.close();
          }
        }
    }
    if ($$self.$$.dirty[0] & /*fullscreen, instance, previousAboveFullscreenShown, $aboveFullscreenShown*/
    201327648) {
      $:
        if (fullscreen && instance3 && previousAboveFullscreenShown !== $aboveFullscreenShown) {
          $$invalidate(26, previousAboveFullscreenShown = $aboveFullscreenShown);
          if ($aboveFullscreenShown) {
            instance3.showSurfaceScrim();
          } else {
            instance3.hideSurfaceScrim();
          }
        }
    }
  };
  return [
    open,
    use,
    className,
    selection,
    autoStackButtons,
    fullscreen,
    sheet,
    noContentPadding,
    container$class,
    surface$class,
    instance3,
    element2,
    internalClasses,
    forwardEvents,
    actionButtonsReversed,
    aboveFullscreenShown,
    handleDialogOpening,
    handleDialogOpened,
    handleDialogClosed,
    $$restProps,
    escapeKeyAction,
    scrimClickAction,
    isOpen,
    setOpen,
    layout,
    getElement,
    previousAboveFullscreenShown,
    $aboveFullscreenShown,
    $$scope,
    slots,
    resize_handler,
    orientationchange_handler,
    transitionend_handler,
    div3_binding
  ];
}
var Dialog = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_1,
      create_fragment,
      safe_not_equal,
      {
        use: 1,
        class: 2,
        open: 0,
        selection: 3,
        escapeKeyAction: 20,
        scrimClickAction: 21,
        autoStackButtons: 4,
        fullscreen: 5,
        sheet: 6,
        noContentPadding: 7,
        container$class: 8,
        surface$class: 9,
        isOpen: 22,
        setOpen: 23,
        layout: 24,
        getElement: 25
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dialog",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selection() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selection(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get escapeKeyAction() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set escapeKeyAction(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrimClickAction() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrimClickAction(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoStackButtons() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoStackButtons(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fullscreen() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fullscreen(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sheet() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sheet(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noContentPadding() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noContentPadding(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container$class() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container$class(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get surface$class() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set surface$class(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    return this.$$.ctx[22];
  }
  set isOpen(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setOpen() {
    return this.$$.ctx[23];
  }
  set setOpen(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get layout() {
    return this.$$.ctx[24];
  }
  set layout(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[25];
  }
  set getElement(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Dialog_default = Dialog;

// node_modules/@smui/common/dist/SmuiElement.svelte
var file2 = "node_modules/@smui/common/dist/SmuiElement.svelte";
function create_else_block(ctx) {
  let previous_tag = (
    /*tag*/
    ctx[1]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*tag*/
    ctx[1]
  );
  validate_void_dynamic_element(
    /*tag*/
    ctx[1]
  );
  let svelte_element = (
    /*tag*/
    ctx[1] && create_dynamic_element_1(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*tag*/
        ctx2[1]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element_1(ctx2);
          previous_tag = /*tag*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*tag*/
          ctx2[1]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*tag*/
            ctx2[1]
          );
          validate_void_dynamic_element(
            /*tag*/
            ctx2[1]
          );
          svelte_element = create_dynamic_element_1(ctx2);
          previous_tag = /*tag*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*tag*/
        ctx2[1];
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(16:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let previous_tag = (
    /*tag*/
    ctx[1]
  );
  let svelte_element_anchor;
  validate_dynamic_element(
    /*tag*/
    ctx[1]
  );
  let svelte_element = (
    /*tag*/
    ctx[1] && create_dynamic_element(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_dev(target, svelte_element_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*tag*/
        ctx2[1]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*tag*/
          ctx2[1]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*tag*/
            ctx2[1]
          );
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*tag*/
        ctx2[1];
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(8:22) ",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let svg;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let svg_levels = [
    /*$$restProps*/
    ctx[5]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (default_slot)
        default_slot.c();
      set_svg_attributes(svg, svg_data);
      add_location(svg, file2, 1, 2, 22);
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      if (default_slot) {
        default_slot.m(svg, null);
      }
      ctx[9](svg);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            svg,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[4].call(null, svg))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [dirty & /*$$restProps*/
      32 && /*$$restProps*/
      ctx2[5]]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[9](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(1:0) {#if tag === 'svg'}",
    ctx
  });
  return block;
}
function create_dynamic_element_1(ctx) {
  let svelte_element;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let svelte_element_levels = [
    /*$$restProps*/
    ctx[5]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*tag*/
        ctx[1]
      );
      if (default_slot)
        default_slot.c();
      set_dynamic_element_data(
        /*tag*/
        ctx[1]
      )(svelte_element, svelte_element_data);
      add_location(svelte_element, file2, 16, 2, 300);
    },
    m: function mount(target, anchor) {
      insert_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      ctx[11](svelte_element);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            svelte_element,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[4].call(null, svelte_element))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_dynamic_element_data(
        /*tag*/
        ctx2[1]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [dirty & /*$$restProps*/
      32 && /*$$restProps*/
      ctx2[5]]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[11](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element_1.name,
    type: "child_dynamic_element",
    source: "(17:2) <svelte:element     this={tag}     bind:this={element}     use:useActions={use}     use:forwardEvents     {...$$restProps}>",
    ctx
  });
  return block;
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let useActions_action;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let svelte_element_levels = [
    /*$$restProps*/
    ctx[5]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*tag*/
        ctx[1]
      );
      set_dynamic_element_data(
        /*tag*/
        ctx[1]
      )(svelte_element, svelte_element_data);
      add_location(svelte_element, file2, 8, 2, 162);
    },
    m: function mount(target, anchor) {
      insert_dev(target, svelte_element, anchor);
      ctx[10](svelte_element);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            svelte_element,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[4].call(null, svelte_element))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_dynamic_element_data(
        /*tag*/
        ctx2[1]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [dirty & /*$$restProps*/
      32 && /*$$restProps*/
      ctx2[5]]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element);
      }
      ctx[10](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element.name,
    type: "child_dynamic_element",
    source: "(9:2) <svelte:element     this={tag}     bind:this={element}     use:useActions={use}     use:forwardEvents     {...$$restProps}   />",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_if_block_1, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*tag*/
      ctx2[1] === "svg"
    )
      return 0;
    if (
      /*selfClosing*/
      ctx2[3]
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let selfClosing;
  const omit_props_names = ["use", "tag", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SmuiElement", slots, ["default"]);
  let { use = [] } = $$props;
  let { tag } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let element2;
  function getElement() {
    return element2;
  }
  $$self.$$.on_mount.push(function() {
    if (tag === void 0 && !("tag" in $$props || $$self.$$.bound[$$self.$$.props["tag"]])) {
      console.warn("<SmuiElement> was created without expected prop 'tag'");
    }
  });
  function svg_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  function svelte_element_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("tag" in $$new_props)
      $$invalidate(1, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    get_current_component,
    forwardEventsBuilder,
    useActions,
    use,
    tag,
    forwardEvents,
    element: element2,
    getElement,
    selfClosing
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("tag" in $$props)
      $$invalidate(1, tag = $$new_props.tag);
    if ("element" in $$props)
      $$invalidate(2, element2 = $$new_props.element);
    if ("selfClosing" in $$props)
      $$invalidate(3, selfClosing = $$new_props.selfClosing);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*tag*/
    2) {
      $:
        $$invalidate(3, selfClosing = [
          "area",
          "base",
          "br",
          "col",
          "embed",
          "hr",
          "img",
          "input",
          "link",
          "meta",
          "param",
          "source",
          "track",
          "wbr"
        ].indexOf(tag) > -1);
    }
  };
  return [
    use,
    tag,
    element2,
    selfClosing,
    forwardEvents,
    $$restProps,
    getElement,
    $$scope,
    slots,
    svg_binding,
    svelte_element_binding,
    svelte_element_binding_1
  ];
}
var SmuiElement = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment2, safe_not_equal, { use: 0, tag: 1, getElement: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SmuiElement",
      options,
      id: create_fragment2.name
    });
  }
  get use() {
    throw new Error("<SmuiElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<SmuiElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<SmuiElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<SmuiElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[6];
  }
  set getElement(value) {
    throw new Error("<SmuiElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SmuiElement_default = SmuiElement;

// node_modules/@smui/common/dist/classadder/ClassAdder.svelte
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(1:0) <svelte:component   this={component}   {tag}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     [smuiClass]: true,     ...smuiClassMap,   })}   {...props}   {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    { tag: (
      /*tag*/
      ctx[3]
    ) },
    {
      use: [
        /*forwardEvents*/
        ctx[8],
        .../*use*/
        ctx[0]
      ]
    },
    {
      class: classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        [
          /*smuiClass*/
          ctx[6]
        ]: true,
        .../*smuiClassMap*/
        ctx[5]
      })
    },
    /*props*/
    ctx[7],
    /*$$restProps*/
    ctx[9]
  ];
  var switch_value = (
    /*component*/
    ctx[2]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    if (dirty !== void 0 && dirty & /*tag, forwardEvents, use, className, smuiClass, smuiClassMap, props, $$restProps*/
    1003) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
        dirty & /*tag*/
        8 && { tag: (
          /*tag*/
          ctx2[3]
        ) },
        dirty & /*forwardEvents, use*/
        257 && {
          use: [
            /*forwardEvents*/
            ctx2[8],
            .../*use*/
            ctx2[0]
          ]
        },
        dirty & /*className, smuiClass, smuiClassMap*/
        98 && {
          class: classMap({
            [
              /*className*/
              ctx2[1]
            ]: true,
            [
              /*smuiClass*/
              ctx2[6]
            ]: true,
            .../*smuiClassMap*/
            ctx2[5]
          })
        },
        dirty & /*props*/
        128 && get_spread_object(
          /*props*/
          ctx2[7]
        ),
        dirty & /*$$restProps*/
        512 && get_spread_object(
          /*$$restProps*/
          ctx2[9]
        )
      ]));
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[12](switch_instance);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*component*/
      4 && switch_value !== (switch_value = /*component*/
      ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          ctx2[12](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*tag, forwardEvents, use, className, smuiClass, smuiClassMap, props, $$restProps*/
        1003 ? get_spread_update(switch_instance_spread_levels, [
          dirty & /*tag*/
          8 && { tag: (
            /*tag*/
            ctx2[3]
          ) },
          dirty & /*forwardEvents, use*/
          257 && {
            use: [
              /*forwardEvents*/
              ctx2[8],
              .../*use*/
              ctx2[0]
            ]
          },
          dirty & /*className, smuiClass, smuiClassMap*/
          98 && {
            class: classMap({
              [
                /*className*/
                ctx2[1]
              ]: true,
              [
                /*smuiClass*/
                ctx2[6]
              ]: true,
              .../*smuiClassMap*/
              ctx2[5]
            })
          },
          dirty & /*props*/
          128 && get_spread_object(
            /*props*/
            ctx2[7]
          ),
          dirty & /*$$restProps*/
          512 && get_spread_object(
            /*$$restProps*/
            ctx2[9]
          )
        ]) : {};
        if (dirty & /*$$scope*/
        8192) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      ctx[12](null);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var internals = {
  component: SmuiElement_default,
  tag: "div",
  class: "",
  classMap: {},
  contexts: {},
  props: {}
};
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "component", "tag", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ClassAdder", slots, ["default"]);
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let element2;
  const smuiClass = internals.class;
  const smuiClassMap = {};
  const smuiClassUnsubscribes = [];
  const contexts = internals.contexts;
  const props = internals.props;
  let { component = internals.component } = $$props;
  let { tag = component === SmuiElement_default ? internals.tag : void 0 } = $$props;
  Object.entries(internals.classMap).forEach(([name, context]) => {
    const store = getContext(context);
    if (store && "subscribe" in store) {
      smuiClassUnsubscribes.push(store.subscribe((value) => {
        $$invalidate(5, smuiClassMap[name] = value, smuiClassMap);
      }));
    }
  });
  const forwardEvents = forwardEventsBuilder(get_current_component());
  for (let context in contexts) {
    if (contexts.hasOwnProperty(context)) {
      setContext(context, contexts[context]);
    }
  }
  onDestroy(() => {
    for (const unsubscribe of smuiClassUnsubscribes) {
      unsubscribe();
    }
  });
  function getElement() {
    return element2.getElement();
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(4, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("component" in $$new_props)
      $$invalidate(2, component = $$new_props.component);
    if ("tag" in $$new_props)
      $$invalidate(3, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    SmuiElement: SmuiElement_default,
    internals,
    onDestroy,
    getContext,
    setContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    use,
    className,
    element: element2,
    smuiClass,
    smuiClassMap,
    smuiClassUnsubscribes,
    contexts,
    props,
    component,
    tag,
    forwardEvents,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(4, element2 = $$new_props.element);
    if ("component" in $$props)
      $$invalidate(2, component = $$new_props.component);
    if ("tag" in $$props)
      $$invalidate(3, tag = $$new_props.tag);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    component,
    tag,
    element2,
    smuiClassMap,
    smuiClass,
    props,
    forwardEvents,
    $$restProps,
    getElement,
    slots,
    switch_instance_binding,
    $$scope
  ];
}
var ClassAdder = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment3, safe_not_equal, {
      use: 0,
      class: 1,
      component: 2,
      tag: 3,
      getElement: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ClassAdder",
      options,
      id: create_fragment3.name
    });
  }
  get use() {
    throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[10];
  }
  set getElement(value) {
    throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ClassAdder_default = ClassAdder;

// node_modules/@smui/common/dist/classadder/classAdderBuilder.js
var defaults = Object.assign({}, internals);
function classAdderBuilder(props) {
  return new Proxy(ClassAdder_default, {
    construct: function(target, args) {
      Object.assign(internals, defaults, props);
      return new target(...args);
    },
    get: function(target, prop) {
      Object.assign(internals, defaults, props);
      return target[prop];
    }
  });
}

// node_modules/@smui/dialog/dist/Header.js
var Header_default = classAdderBuilder({
  class: "mdc-dialog__header",
  tag: "div",
  contexts: {
    "SMUI:icon-button:context": "dialog:header"
  }
});

// node_modules/@smui/dialog/dist/Title.js
var Title_default = classAdderBuilder({
  class: "mdc-dialog__title",
  tag: "h2"
});

// node_modules/@smui/dialog/dist/Content.js
var Content_default = classAdderBuilder({
  class: "mdc-dialog__content",
  tag: "div"
});

// node_modules/@smui/dialog/dist/Actions.js
var Actions_default = classAdderBuilder({
  class: "mdc-dialog__actions",
  tag: "div",
  classMap: {
    "smui-dialog__actions--reversed": "SMUI:dialog:actions:reversed"
  },
  contexts: {
    "SMUI:button:context": "dialog:action"
  }
});

// node_modules/@smui/dialog/dist/InitialFocus.js
function InitialFocus(node) {
  node.setAttribute("data-mdc-dialog-initial-focus", "");
  return {
    destroy() {
      node.removeAttribute("data-mdc-dialog-initial-focus");
    }
  };
}

// node_modules/@smui/dialog/dist/index.js
var dist_default = Dialog_default;
export {
  Actions_default as Actions,
  Content_default as Content,
  Header_default as Header,
  InitialFocus,
  Title_default as Title,
  dist_default as default
};
/*! Bundled license information:

@material/dialog/util.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/dialog/adapter.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/base/foundation.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/base/component.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/dom/focus-trap.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/dom/ponyfill.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/dom/events.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/ripple/constants.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/ripple/foundation.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/ripple/component.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/animation/animationframe.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/dialog/constants.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/dialog/foundation.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/dialog/component.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/dialog/types.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/dialog/index.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/dom/keyboard.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/dom/index.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)
*/
//# sourceMappingURL=@smui_dialog.js.map
