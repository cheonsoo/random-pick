import {
  AnimationFrame,
  ContextFragment_default,
  KEY,
  MDCComponent,
  MDCFoundation,
  MDCRipple,
  MDCRippleFoundation,
  SmuiElement_default,
  __assign,
  __extends,
  __read,
  __values,
  announce,
  classMap,
  closest,
  dispatch,
  events_exports,
  exclude,
  forwardEventsBuilder,
  isNavigationEvent,
  normalizeKey,
  ponyfill_exports,
  prefixFilter,
  useActions,
  util_exports
} from "./chunk-UNODMIMA.js";
import {
  writable
} from "./chunk-OPF4ZEBV.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_dev,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  component_subscribe,
  compute_rest_props,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onMount,
  outro_and_destroy_block,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  set_store_value,
  space,
  svg_element,
  tick,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-ICTIXKQX.js";
import "./chunk-BI2WGJ4V.js";
import {
  __export
} from "./chunk-MIDELY2Q.js";

// node_modules/@material/chips/action/component-ripple.js
function computePrimaryActionRippleClientRect(clientRect, graphicSelectedWidthStyleValue) {
  var graphicWidth = Number(graphicSelectedWidthStyleValue.replace("px", ""));
  if (Number.isNaN(graphicWidth)) {
    return clientRect;
  }
  return {
    width: clientRect.width + graphicWidth,
    height: clientRect.height,
    top: clientRect.top,
    right: clientRect.right,
    bottom: clientRect.bottom,
    left: clientRect.left
  };
}
var GRAPHIC_SELECTED_WIDTH_STYLE_PROP = "--mdc-chip-graphic-selected-width";

// node_modules/@material/chips/action/constants.js
var MDCChipActionCssClasses;
(function(MDCChipActionCssClasses2) {
  MDCChipActionCssClasses2["PRIMARY_ACTION"] = "mdc-evolution-chip__action--primary";
  MDCChipActionCssClasses2["TRAILING_ACTION"] = "mdc-evolution-chip__action--trailing";
  MDCChipActionCssClasses2["CHIP_ROOT"] = "mdc-evolution-chip";
})(MDCChipActionCssClasses || (MDCChipActionCssClasses = {}));
var MDCChipActionInteractionTrigger;
(function(MDCChipActionInteractionTrigger2) {
  MDCChipActionInteractionTrigger2[MDCChipActionInteractionTrigger2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  MDCChipActionInteractionTrigger2[MDCChipActionInteractionTrigger2["CLICK"] = 1] = "CLICK";
  MDCChipActionInteractionTrigger2[MDCChipActionInteractionTrigger2["BACKSPACE_KEY"] = 2] = "BACKSPACE_KEY";
  MDCChipActionInteractionTrigger2[MDCChipActionInteractionTrigger2["DELETE_KEY"] = 3] = "DELETE_KEY";
  MDCChipActionInteractionTrigger2[MDCChipActionInteractionTrigger2["SPACEBAR_KEY"] = 4] = "SPACEBAR_KEY";
  MDCChipActionInteractionTrigger2[MDCChipActionInteractionTrigger2["ENTER_KEY"] = 5] = "ENTER_KEY";
})(MDCChipActionInteractionTrigger || (MDCChipActionInteractionTrigger = {}));
var MDCChipActionType;
(function(MDCChipActionType2) {
  MDCChipActionType2[MDCChipActionType2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  MDCChipActionType2[MDCChipActionType2["PRIMARY"] = 1] = "PRIMARY";
  MDCChipActionType2[MDCChipActionType2["TRAILING"] = 2] = "TRAILING";
})(MDCChipActionType || (MDCChipActionType = {}));
var MDCChipActionEvents;
(function(MDCChipActionEvents2) {
  MDCChipActionEvents2["INTERACTION"] = "MDCChipAction:interaction";
  MDCChipActionEvents2["NAVIGATION"] = "MDCChipAction:navigation";
})(MDCChipActionEvents || (MDCChipActionEvents = {}));
var MDCChipActionFocusBehavior;
(function(MDCChipActionFocusBehavior2) {
  MDCChipActionFocusBehavior2[MDCChipActionFocusBehavior2["FOCUSABLE"] = 0] = "FOCUSABLE";
  MDCChipActionFocusBehavior2[MDCChipActionFocusBehavior2["FOCUSABLE_AND_FOCUSED"] = 1] = "FOCUSABLE_AND_FOCUSED";
  MDCChipActionFocusBehavior2[MDCChipActionFocusBehavior2["NOT_FOCUSABLE"] = 2] = "NOT_FOCUSABLE";
})(MDCChipActionFocusBehavior || (MDCChipActionFocusBehavior = {}));
var MDCChipActionAttributes;
(function(MDCChipActionAttributes2) {
  MDCChipActionAttributes2["ARIA_DISABLED"] = "aria-disabled";
  MDCChipActionAttributes2["ARIA_HIDDEN"] = "aria-hidden";
  MDCChipActionAttributes2["ARIA_SELECTED"] = "aria-selected";
  MDCChipActionAttributes2["DATA_DELETABLE"] = "data-mdc-deletable";
  MDCChipActionAttributes2["DISABLED"] = "disabled";
  MDCChipActionAttributes2["ROLE"] = "role";
  MDCChipActionAttributes2["TAB_INDEX"] = "tabindex";
})(MDCChipActionAttributes || (MDCChipActionAttributes = {}));

// node_modules/@material/chips/action/foundation.js
var triggerMap = /* @__PURE__ */ new Map();
triggerMap.set(KEY.SPACEBAR, MDCChipActionInteractionTrigger.SPACEBAR_KEY);
triggerMap.set(KEY.ENTER, MDCChipActionInteractionTrigger.ENTER_KEY);
triggerMap.set(KEY.DELETE, MDCChipActionInteractionTrigger.DELETE_KEY);
triggerMap.set(KEY.BACKSPACE, MDCChipActionInteractionTrigger.BACKSPACE_KEY);
var MDCChipActionFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCChipActionFoundation2, _super);
    function MDCChipActionFoundation2(adapter) {
      return _super.call(this, __assign(__assign({}, MDCChipActionFoundation2.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCChipActionFoundation2, "defaultAdapter", {
      get: function() {
        return {
          emitEvent: function() {
            return void 0;
          },
          focus: function() {
            return void 0;
          },
          getAttribute: function() {
            return null;
          },
          getElementID: function() {
            return "";
          },
          removeAttribute: function() {
            return void 0;
          },
          setAttribute: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCChipActionFoundation2.prototype.handleClick = function() {
      if (this.isDisabled())
        return;
      this.emitInteraction(MDCChipActionInteractionTrigger.CLICK);
    };
    MDCChipActionFoundation2.prototype.handleKeydown = function(event) {
      var key = normalizeKey(event);
      if (this.shouldNotifyInteractionFromKey(key)) {
        event.preventDefault();
        this.emitInteraction(this.getTriggerFromKey(key));
        return;
      }
      if (isNavigationEvent(event)) {
        event.preventDefault();
        this.emitNavigation(key);
        return;
      }
    };
    MDCChipActionFoundation2.prototype.setDisabled = function(isDisabled) {
      if (this.isSelectable()) {
        this.adapter.setAttribute(MDCChipActionAttributes.ARIA_DISABLED, "" + isDisabled);
        return;
      }
      if (isDisabled) {
        this.adapter.setAttribute(MDCChipActionAttributes.DISABLED, "true");
      } else {
        this.adapter.removeAttribute(MDCChipActionAttributes.DISABLED);
      }
    };
    MDCChipActionFoundation2.prototype.isDisabled = function() {
      if (this.adapter.getAttribute(MDCChipActionAttributes.ARIA_DISABLED) === "true") {
        return true;
      }
      if (this.adapter.getAttribute(MDCChipActionAttributes.DISABLED) !== null) {
        return true;
      }
      return false;
    };
    MDCChipActionFoundation2.prototype.setFocus = function(behavior) {
      if (!this.isFocusable()) {
        return;
      }
      if (behavior === MDCChipActionFocusBehavior.FOCUSABLE_AND_FOCUSED) {
        this.adapter.setAttribute(MDCChipActionAttributes.TAB_INDEX, "0");
        this.adapter.focus();
        return;
      }
      if (behavior === MDCChipActionFocusBehavior.FOCUSABLE) {
        this.adapter.setAttribute(MDCChipActionAttributes.TAB_INDEX, "0");
        return;
      }
      if (behavior === MDCChipActionFocusBehavior.NOT_FOCUSABLE) {
        this.adapter.setAttribute(MDCChipActionAttributes.TAB_INDEX, "-1");
        return;
      }
    };
    MDCChipActionFoundation2.prototype.isFocusable = function() {
      if (this.isDisabled()) {
        return false;
      }
      if (this.adapter.getAttribute(MDCChipActionAttributes.ARIA_HIDDEN) === "true") {
        return false;
      }
      return true;
    };
    MDCChipActionFoundation2.prototype.setSelected = function(isSelected) {
      if (!this.isSelectable()) {
        return;
      }
      this.adapter.setAttribute(MDCChipActionAttributes.ARIA_SELECTED, "" + isSelected);
    };
    MDCChipActionFoundation2.prototype.isSelected = function() {
      return this.adapter.getAttribute(MDCChipActionAttributes.ARIA_SELECTED) === "true";
    };
    MDCChipActionFoundation2.prototype.emitInteraction = function(trigger) {
      this.adapter.emitEvent(MDCChipActionEvents.INTERACTION, {
        actionID: this.adapter.getElementID(),
        source: this.actionType(),
        trigger
      });
    };
    MDCChipActionFoundation2.prototype.emitNavigation = function(key) {
      this.adapter.emitEvent(MDCChipActionEvents.NAVIGATION, {
        source: this.actionType(),
        key
      });
    };
    MDCChipActionFoundation2.prototype.shouldNotifyInteractionFromKey = function(key) {
      var isFromActionKey = key === KEY.ENTER || key === KEY.SPACEBAR;
      var isFromRemoveKey = key === KEY.BACKSPACE || key === KEY.DELETE;
      if (isFromActionKey) {
        return true;
      }
      if (isFromRemoveKey && this.shouldEmitInteractionOnRemoveKey()) {
        return true;
      }
      return false;
    };
    MDCChipActionFoundation2.prototype.getTriggerFromKey = function(key) {
      var trigger = triggerMap.get(key);
      if (trigger) {
        return trigger;
      }
      return MDCChipActionInteractionTrigger.UNSPECIFIED;
    };
    return MDCChipActionFoundation2;
  }(MDCFoundation)
);

// node_modules/@material/chips/action/primary-foundation.js
var MDCChipPrimaryActionFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCChipPrimaryActionFoundation2, _super);
    function MDCChipPrimaryActionFoundation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCChipPrimaryActionFoundation2.prototype.isSelectable = function() {
      return this.adapter.getAttribute(MDCChipActionAttributes.ROLE) === "option";
    };
    MDCChipPrimaryActionFoundation2.prototype.actionType = function() {
      return MDCChipActionType.PRIMARY;
    };
    MDCChipPrimaryActionFoundation2.prototype.shouldEmitInteractionOnRemoveKey = function() {
      return this.adapter.getAttribute(MDCChipActionAttributes.DATA_DELETABLE) === "true";
    };
    return MDCChipPrimaryActionFoundation2;
  }(MDCChipActionFoundation)
);

// node_modules/@material/chips/action/trailing-foundation.js
var MDCChipTrailingActionFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCChipTrailingActionFoundation3, _super);
    function MDCChipTrailingActionFoundation3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCChipTrailingActionFoundation3.prototype.isSelectable = function() {
      return false;
    };
    MDCChipTrailingActionFoundation3.prototype.actionType = function() {
      return MDCChipActionType.TRAILING;
    };
    MDCChipTrailingActionFoundation3.prototype.shouldEmitInteractionOnRemoveKey = function() {
      return true;
    };
    return MDCChipTrailingActionFoundation3;
  }(MDCChipActionFoundation)
);

// node_modules/@material/chips/action/component.js
var MDCChipAction = (
  /** @class */
  function(_super) {
    __extends(MDCChipAction2, _super);
    function MDCChipAction2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.rootHTML = _this.root;
      return _this;
    }
    MDCChipAction2.attachTo = function(root) {
      return new MDCChipAction2(root);
    };
    Object.defineProperty(MDCChipAction2.prototype, "ripple", {
      get: function() {
        return this.rippleInstance;
      },
      enumerable: false,
      configurable: true
    });
    MDCChipAction2.prototype.initialize = function(rippleFactory) {
      var _this = this;
      if (rippleFactory === void 0) {
        rippleFactory = function(el, foundation) {
          return new MDCRipple(el, foundation);
        };
      }
      var rippleAdapter = __assign(__assign({}, MDCRipple.createAdapter(this)), { computeBoundingRect: function() {
        return _this.computeRippleClientRect();
      } });
      this.rippleInstance = rippleFactory(this.root, new MDCRippleFoundation(rippleAdapter));
    };
    MDCChipAction2.prototype.initialSyncWithDOM = function() {
      var _this = this;
      this.handleClick = function() {
        _this.foundation.handleClick();
      };
      this.handleKeydown = function(event) {
        _this.foundation.handleKeydown(event);
      };
      this.listen("click", this.handleClick);
      this.listen("keydown", this.handleKeydown);
    };
    MDCChipAction2.prototype.destroy = function() {
      this.ripple.destroy();
      this.unlisten("click", this.handleClick);
      this.unlisten("keydown", this.handleKeydown);
      _super.prototype.destroy.call(this);
    };
    MDCChipAction2.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        emitEvent: function(eventName, eventDetail) {
          _this.emit(
            eventName,
            eventDetail,
            true
            /* shouldBubble */
          );
        },
        focus: function() {
          _this.rootHTML.focus();
        },
        getAttribute: function(attrName) {
          return _this.root.getAttribute(attrName);
        },
        getElementID: function() {
          return _this.root.id;
        },
        removeAttribute: function(name) {
          _this.root.removeAttribute(name);
        },
        setAttribute: function(name, value) {
          _this.root.setAttribute(name, value);
        }
      };
      if (this.root.classList.contains(MDCChipActionCssClasses.TRAILING_ACTION)) {
        return new MDCChipTrailingActionFoundation(adapter);
      }
      return new MDCChipPrimaryActionFoundation(adapter);
    };
    MDCChipAction2.prototype.setDisabled = function(isDisabled) {
      this.foundation.setDisabled(isDisabled);
    };
    MDCChipAction2.prototype.isDisabled = function() {
      return this.foundation.isDisabled();
    };
    MDCChipAction2.prototype.setFocus = function(behavior) {
      this.foundation.setFocus(behavior);
    };
    MDCChipAction2.prototype.isFocusable = function() {
      return this.foundation.isFocusable();
    };
    MDCChipAction2.prototype.setSelected = function(isSelected) {
      this.foundation.setSelected(isSelected);
    };
    MDCChipAction2.prototype.isSelected = function() {
      return this.foundation.isSelected();
    };
    MDCChipAction2.prototype.isSelectable = function() {
      return this.foundation.isSelectable();
    };
    MDCChipAction2.prototype.actionType = function() {
      return this.foundation.actionType();
    };
    MDCChipAction2.prototype.computeRippleClientRect = function() {
      if (this.root.classList.contains(MDCChipActionCssClasses.PRIMARY_ACTION)) {
        var chipRoot = closest(this.root, "." + MDCChipActionCssClasses.CHIP_ROOT);
        if (!chipRoot)
          return this.root.getBoundingClientRect();
        var graphicWidth = window.getComputedStyle(chipRoot).getPropertyValue(GRAPHIC_SELECTED_WIDTH_STYLE_PROP);
        return computePrimaryActionRippleClientRect(chipRoot.getBoundingClientRect(), graphicWidth);
      }
      return this.root.getBoundingClientRect();
    };
    return MDCChipAction2;
  }(MDCComponent)
);

// node_modules/@material/chips/chip/constants.js
var MDCChipCssClasses;
(function(MDCChipCssClasses2) {
  MDCChipCssClasses2["SELECTING"] = "mdc-evolution-chip--selecting";
  MDCChipCssClasses2["DESELECTING"] = "mdc-evolution-chip--deselecting";
  MDCChipCssClasses2["SELECTING_WITH_PRIMARY_ICON"] = "mdc-evolution-chip--selecting-with-primary-icon";
  MDCChipCssClasses2["DESELECTING_WITH_PRIMARY_ICON"] = "mdc-evolution-chip--deselecting-with-primary-icon";
  MDCChipCssClasses2["DISABLED"] = "mdc-evolution-chip--disabled";
  MDCChipCssClasses2["ENTER"] = "mdc-evolution-chip--enter";
  MDCChipCssClasses2["EXIT"] = "mdc-evolution-chip--exit";
  MDCChipCssClasses2["SELECTED"] = "mdc-evolution-chip--selected";
  MDCChipCssClasses2["HIDDEN"] = "mdc-evolution-chip--hidden";
  MDCChipCssClasses2["WITH_PRIMARY_ICON"] = "mdc-evolution-chip--with-primary-icon";
})(MDCChipCssClasses || (MDCChipCssClasses = {}));
var MDCChipEvents;
(function(MDCChipEvents2) {
  MDCChipEvents2["INTERACTION"] = "MDCChip:interaction";
  MDCChipEvents2["NAVIGATION"] = "MDCChip:navigation";
  MDCChipEvents2["ANIMATION"] = "MDCChip:animation";
})(MDCChipEvents || (MDCChipEvents = {}));
var MDCChipAttributes;
(function(MDCChipAttributes2) {
  MDCChipAttributes2["DATA_REMOVED_ANNOUNCEMENT"] = "data-mdc-removed-announcement";
  MDCChipAttributes2["DATA_ADDED_ANNOUNCEMENT"] = "data-mdc-added-announcement";
})(MDCChipAttributes || (MDCChipAttributes = {}));
var MDCChipAnimation;
(function(MDCChipAnimation2) {
  MDCChipAnimation2["ENTER"] = "mdc-evolution-chip-enter";
  MDCChipAnimation2["EXIT"] = "mdc-evolution-chip-exit";
})(MDCChipAnimation || (MDCChipAnimation = {}));

// node_modules/@material/chips/chip/foundation.js
var Direction;
(function(Direction3) {
  Direction3[Direction3["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  Direction3[Direction3["LEFT"] = 1] = "LEFT";
  Direction3[Direction3["RIGHT"] = 2] = "RIGHT";
})(Direction || (Direction = {}));
var AnimationKeys;
(function(AnimationKeys2) {
  AnimationKeys2["SELECTION"] = "selection";
  AnimationKeys2["EXIT"] = "exit";
})(AnimationKeys || (AnimationKeys = {}));
var MDCChipFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCChipFoundation3, _super);
    function MDCChipFoundation3(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCChipFoundation3.defaultAdapter), adapter)) || this;
      _this.animFrame = new AnimationFrame();
      return _this;
    }
    Object.defineProperty(MDCChipFoundation3, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          emitEvent: function() {
            return void 0;
          },
          getActions: function() {
            return [];
          },
          getAttribute: function() {
            return null;
          },
          getElementID: function() {
            return "";
          },
          getOffsetWidth: function() {
            return 0;
          },
          hasClass: function() {
            return false;
          },
          isActionDisabled: function() {
            return false;
          },
          isActionFocusable: function() {
            return false;
          },
          isActionSelectable: function() {
            return false;
          },
          isActionSelected: function() {
            return false;
          },
          isRTL: function() {
            return false;
          },
          removeClass: function() {
            return void 0;
          },
          setActionDisabled: function() {
            return void 0;
          },
          setActionFocus: function() {
            return void 0;
          },
          setActionSelected: function() {
            return void 0;
          },
          setStyleProperty: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCChipFoundation3.prototype.destroy = function() {
      this.animFrame.cancelAll();
    };
    MDCChipFoundation3.prototype.getElementID = function() {
      return this.adapter.getElementID();
    };
    MDCChipFoundation3.prototype.setDisabled = function(isDisabled) {
      var e_1, _a2;
      var actions = this.getActions();
      try {
        for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {
          var action = actions_1_1.value;
          this.adapter.setActionDisabled(action, isDisabled);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (actions_1_1 && !actions_1_1.done && (_a2 = actions_1.return))
            _a2.call(actions_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (isDisabled) {
        this.adapter.addClass(MDCChipCssClasses.DISABLED);
      } else {
        this.adapter.removeClass(MDCChipCssClasses.DISABLED);
      }
    };
    MDCChipFoundation3.prototype.isDisabled = function() {
      var e_2, _a2;
      var actions = this.getActions();
      try {
        for (var actions_2 = __values(actions), actions_2_1 = actions_2.next(); !actions_2_1.done; actions_2_1 = actions_2.next()) {
          var action = actions_2_1.value;
          if (this.adapter.isActionDisabled(action)) {
            return true;
          }
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (actions_2_1 && !actions_2_1.done && (_a2 = actions_2.return))
            _a2.call(actions_2);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      return false;
    };
    MDCChipFoundation3.prototype.getActions = function() {
      return this.adapter.getActions();
    };
    MDCChipFoundation3.prototype.isActionFocusable = function(action) {
      return this.adapter.isActionFocusable(action);
    };
    MDCChipFoundation3.prototype.isActionSelectable = function(action) {
      return this.adapter.isActionSelectable(action);
    };
    MDCChipFoundation3.prototype.isActionSelected = function(action) {
      return this.adapter.isActionSelected(action);
    };
    MDCChipFoundation3.prototype.setActionFocus = function(action, focus) {
      this.adapter.setActionFocus(action, focus);
    };
    MDCChipFoundation3.prototype.setActionSelected = function(action, isSelected) {
      this.adapter.setActionSelected(action, isSelected);
      this.animateSelection(isSelected);
    };
    MDCChipFoundation3.prototype.startAnimation = function(animation) {
      if (animation === MDCChipAnimation.ENTER) {
        this.adapter.addClass(MDCChipCssClasses.ENTER);
        return;
      }
      if (animation === MDCChipAnimation.EXIT) {
        this.adapter.addClass(MDCChipCssClasses.EXIT);
        return;
      }
    };
    MDCChipFoundation3.prototype.handleAnimationEnd = function(event) {
      var _this = this;
      var animationName = event.animationName;
      if (animationName === MDCChipAnimation.ENTER) {
        this.adapter.removeClass(MDCChipCssClasses.ENTER);
        this.adapter.emitEvent(MDCChipEvents.ANIMATION, {
          chipID: this.getElementID(),
          animation: MDCChipAnimation.ENTER,
          addedAnnouncement: this.getAddedAnnouncement(),
          isComplete: true
        });
        return;
      }
      if (animationName === MDCChipAnimation.EXIT) {
        this.adapter.removeClass(MDCChipCssClasses.EXIT);
        this.adapter.addClass(MDCChipCssClasses.HIDDEN);
        var width = this.adapter.getOffsetWidth();
        this.adapter.setStyleProperty("width", width + "px");
        this.animFrame.request(AnimationKeys.EXIT, function() {
          _this.animFrame.request(AnimationKeys.EXIT, function() {
            _this.adapter.setStyleProperty("width", "0");
          });
        });
      }
    };
    MDCChipFoundation3.prototype.handleTransitionEnd = function() {
      if (!this.adapter.hasClass(MDCChipCssClasses.HIDDEN))
        return;
      this.adapter.emitEvent(MDCChipEvents.ANIMATION, {
        chipID: this.getElementID(),
        animation: MDCChipAnimation.EXIT,
        removedAnnouncement: this.getRemovedAnnouncement(),
        isComplete: true
      });
    };
    MDCChipFoundation3.prototype.handleActionInteraction = function(_a2) {
      var detail = _a2.detail;
      var source = detail.source, actionID = detail.actionID;
      var isSelectable = this.adapter.isActionSelectable(source);
      var isSelected = this.adapter.isActionSelected(source);
      this.adapter.emitEvent(MDCChipEvents.INTERACTION, {
        chipID: this.getElementID(),
        shouldRemove: this.shouldRemove(detail),
        actionID,
        isSelectable,
        isSelected,
        source
      });
    };
    MDCChipFoundation3.prototype.handleActionNavigation = function(_a2) {
      var detail = _a2.detail;
      var source = detail.source, key = detail.key;
      var isRTL = this.adapter.isRTL();
      var isTrailingActionFocusable = this.adapter.isActionFocusable(MDCChipActionType.TRAILING);
      var isPrimaryActionFocusable = this.adapter.isActionFocusable(MDCChipActionType.PRIMARY);
      var dir = this.directionFromKey(key, isRTL);
      var shouldNavigateToTrailing = source === MDCChipActionType.PRIMARY && dir === Direction.RIGHT && isTrailingActionFocusable;
      var shouldNavigateToPrimary = source === MDCChipActionType.TRAILING && dir === Direction.LEFT && isPrimaryActionFocusable;
      if (shouldNavigateToTrailing) {
        this.navigateActions({ from: source, to: MDCChipActionType.TRAILING });
        return;
      }
      if (shouldNavigateToPrimary) {
        this.navigateActions({ from: source, to: MDCChipActionType.PRIMARY });
        return;
      }
      this.adapter.emitEvent(MDCChipEvents.NAVIGATION, {
        chipID: this.getElementID(),
        isRTL,
        source,
        key
      });
    };
    MDCChipFoundation3.prototype.directionFromKey = function(key, isRTL) {
      var isLeftKey = key === KEY.ARROW_LEFT;
      var isRightKey = key === KEY.ARROW_RIGHT;
      if (!isRTL && isLeftKey || isRTL && isRightKey) {
        return Direction.LEFT;
      }
      if (!isRTL && isRightKey || isRTL && isLeftKey) {
        return Direction.RIGHT;
      }
      return Direction.UNSPECIFIED;
    };
    MDCChipFoundation3.prototype.navigateActions = function(nav) {
      this.adapter.setActionFocus(nav.from, MDCChipActionFocusBehavior.NOT_FOCUSABLE);
      this.adapter.setActionFocus(nav.to, MDCChipActionFocusBehavior.FOCUSABLE_AND_FOCUSED);
    };
    MDCChipFoundation3.prototype.shouldRemove = function(_a2) {
      var source = _a2.source, trigger = _a2.trigger;
      if (trigger === MDCChipActionInteractionTrigger.BACKSPACE_KEY || trigger === MDCChipActionInteractionTrigger.DELETE_KEY) {
        return true;
      }
      return source === MDCChipActionType.TRAILING;
    };
    MDCChipFoundation3.prototype.getRemovedAnnouncement = function() {
      var msg = this.adapter.getAttribute(MDCChipAttributes.DATA_REMOVED_ANNOUNCEMENT);
      return msg || void 0;
    };
    MDCChipFoundation3.prototype.getAddedAnnouncement = function() {
      var msg = this.adapter.getAttribute(MDCChipAttributes.DATA_ADDED_ANNOUNCEMENT);
      return msg || void 0;
    };
    MDCChipFoundation3.prototype.animateSelection = function(isSelected) {
      var _this = this;
      this.resetAnimationStyles();
      this.animFrame.request(AnimationKeys.SELECTION, function() {
        _this.animFrame.request(AnimationKeys.SELECTION, function() {
          _this.updateSelectionStyles(isSelected);
        });
      });
    };
    MDCChipFoundation3.prototype.resetAnimationStyles = function() {
      this.adapter.removeClass(MDCChipCssClasses.SELECTING);
      this.adapter.removeClass(MDCChipCssClasses.DESELECTING);
      this.adapter.removeClass(MDCChipCssClasses.SELECTING_WITH_PRIMARY_ICON);
      this.adapter.removeClass(MDCChipCssClasses.DESELECTING_WITH_PRIMARY_ICON);
    };
    MDCChipFoundation3.prototype.updateSelectionStyles = function(isSelected) {
      var _this = this;
      var hasIcon = this.adapter.hasClass(MDCChipCssClasses.WITH_PRIMARY_ICON);
      if (hasIcon && isSelected) {
        this.adapter.addClass(MDCChipCssClasses.SELECTING_WITH_PRIMARY_ICON);
        this.animFrame.request(AnimationKeys.SELECTION, function() {
          _this.adapter.addClass(MDCChipCssClasses.SELECTED);
        });
        return;
      }
      if (hasIcon && !isSelected) {
        this.adapter.addClass(MDCChipCssClasses.DESELECTING_WITH_PRIMARY_ICON);
        this.animFrame.request(AnimationKeys.SELECTION, function() {
          _this.adapter.removeClass(MDCChipCssClasses.SELECTED);
        });
        return;
      }
      if (isSelected) {
        this.adapter.addClass(MDCChipCssClasses.SELECTING);
        this.animFrame.request(AnimationKeys.SELECTION, function() {
          _this.adapter.addClass(MDCChipCssClasses.SELECTED);
        });
        return;
      }
      if (!isSelected) {
        this.adapter.addClass(MDCChipCssClasses.DESELECTING);
        this.animFrame.request(AnimationKeys.SELECTION, function() {
          _this.adapter.removeClass(MDCChipCssClasses.SELECTED);
        });
        return;
      }
    };
    return MDCChipFoundation3;
  }(MDCFoundation)
);

// node_modules/@material/chips/chip/component.js
var MDCChip = (
  /** @class */
  function(_super) {
    __extends(MDCChip3, _super);
    function MDCChip3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.rootHTML = _this.root;
      return _this;
    }
    MDCChip3.attachTo = function(root) {
      return new MDCChip3(root);
    };
    MDCChip3.prototype.initialize = function(actionFactory) {
      if (actionFactory === void 0) {
        actionFactory = function(el) {
          return new MDCChipAction(el);
        };
      }
      this.actions = /* @__PURE__ */ new Map();
      var actionEls = this.root.querySelectorAll(".mdc-evolution-chip__action");
      for (var i = 0; i < actionEls.length; i++) {
        var action = actionFactory(actionEls[i]);
        this.actions.set(action.actionType(), action);
      }
    };
    MDCChip3.prototype.initialSyncWithDOM = function() {
      var _this = this;
      this.handleActionInteraction = function(event) {
        _this.foundation.handleActionInteraction(event);
      };
      this.handleActionNavigation = function(event) {
        _this.foundation.handleActionNavigation(event);
      };
      this.listen(MDCChipActionEvents.INTERACTION, this.handleActionInteraction);
      this.listen(MDCChipActionEvents.NAVIGATION, this.handleActionNavigation);
    };
    MDCChip3.prototype.destroy = function() {
      this.unlisten(MDCChipActionEvents.INTERACTION, this.handleActionInteraction);
      this.unlisten(MDCChipActionEvents.NAVIGATION, this.handleActionNavigation);
      _super.prototype.destroy.call(this);
    };
    MDCChip3.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        addClass: function(className) {
          _this.root.classList.add(className);
        },
        emitEvent: function(eventName, eventDetail) {
          _this.emit(
            eventName,
            eventDetail,
            true
            /* shouldBubble */
          );
        },
        getActions: function() {
          var e_1, _a2;
          var actions = [];
          try {
            for (var _b = __values(_this.actions), _c = _b.next(); !_c.done; _c = _b.next()) {
              var _d = __read(_c.value, 1), key = _d[0];
              actions.push(key);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a2 = _b.return))
                _a2.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          return actions;
        },
        getAttribute: function(attrName) {
          return _this.root.getAttribute(attrName);
        },
        getElementID: function() {
          return _this.rootHTML.id;
        },
        getOffsetWidth: function() {
          return _this.rootHTML.offsetWidth;
        },
        hasClass: function(className) {
          return _this.root.classList.contains(className);
        },
        isActionSelectable: function(actionType) {
          var action = _this.actions.get(actionType);
          if (action) {
            return action.isSelectable();
          }
          return false;
        },
        isActionSelected: function(actionType) {
          var action = _this.actions.get(actionType);
          if (action) {
            return action.isSelected();
          }
          return false;
        },
        isActionFocusable: function(actionType) {
          var action = _this.actions.get(actionType);
          if (action) {
            return action.isFocusable();
          }
          return false;
        },
        isActionDisabled: function(actionType) {
          var action = _this.actions.get(actionType);
          if (action) {
            return action.isDisabled();
          }
          return false;
        },
        isRTL: function() {
          return window.getComputedStyle(_this.root).getPropertyValue("direction") === "rtl";
        },
        removeClass: function(className) {
          _this.root.classList.remove(className);
        },
        setActionDisabled: function(actionType, isDisabled) {
          var action = _this.actions.get(actionType);
          if (action) {
            action.setDisabled(isDisabled);
          }
        },
        setActionFocus: function(actionType, behavior) {
          var action = _this.actions.get(actionType);
          if (action) {
            action.setFocus(behavior);
          }
        },
        setActionSelected: function(actionType, isSelected) {
          var action = _this.actions.get(actionType);
          if (action) {
            action.setSelected(isSelected);
          }
        },
        setStyleProperty: function(prop, value) {
          _this.rootHTML.style.setProperty(prop, value);
        }
      };
      return new MDCChipFoundation(adapter);
    };
    MDCChip3.prototype.remove = function() {
      var parent = this.root.parentNode;
      if (parent !== null) {
        parent.removeChild(this.root);
      }
    };
    MDCChip3.prototype.getActions = function() {
      return this.foundation.getActions();
    };
    MDCChip3.prototype.getElementID = function() {
      return this.foundation.getElementID();
    };
    MDCChip3.prototype.isDisabled = function() {
      return this.foundation.isDisabled();
    };
    MDCChip3.prototype.setDisabled = function(isDisabled) {
      this.foundation.setDisabled(isDisabled);
    };
    MDCChip3.prototype.isActionFocusable = function(action) {
      return this.foundation.isActionFocusable(action);
    };
    MDCChip3.prototype.isActionSelectable = function(action) {
      return this.foundation.isActionSelectable(action);
    };
    MDCChip3.prototype.isActionSelected = function(action) {
      return this.foundation.isActionSelected(action);
    };
    MDCChip3.prototype.setActionFocus = function(action, focus) {
      this.foundation.setActionFocus(action, focus);
    };
    MDCChip3.prototype.setActionSelected = function(action, isSelected) {
      this.foundation.setActionSelected(action, isSelected);
    };
    MDCChip3.prototype.startAnimation = function(animation) {
      this.foundation.startAnimation(animation);
    };
    return MDCChip3;
  }(MDCComponent)
);

// node_modules/@material/dom/announce.js
var AnnouncerPriority;
(function(AnnouncerPriority2) {
  AnnouncerPriority2["POLITE"] = "polite";
  AnnouncerPriority2["ASSERTIVE"] = "assertive";
})(AnnouncerPriority || (AnnouncerPriority = {}));
var DATA_MDC_DOM_ANNOUNCE = "data-mdc-dom-announce";
function announce2(message, options) {
  Announcer.getInstance().say(message, options);
}
var Announcer = (
  /** @class */
  function() {
    function Announcer2() {
      this.liveRegions = /* @__PURE__ */ new Map();
    }
    Announcer2.getInstance = function() {
      if (!Announcer2.instance) {
        Announcer2.instance = new Announcer2();
      }
      return Announcer2.instance;
    };
    Announcer2.prototype.say = function(message, options) {
      var _a2, _b;
      var priority = (_a2 = options === null || options === void 0 ? void 0 : options.priority) !== null && _a2 !== void 0 ? _a2 : AnnouncerPriority.POLITE;
      var ownerDocument = (_b = options === null || options === void 0 ? void 0 : options.ownerDocument) !== null && _b !== void 0 ? _b : document;
      var liveRegion = this.getLiveRegion(priority, ownerDocument);
      liveRegion.textContent = "";
      setTimeout(function() {
        liveRegion.textContent = message;
        ownerDocument.addEventListener("click", clearLiveRegion);
      }, 1);
      function clearLiveRegion() {
        liveRegion.textContent = "";
        ownerDocument.removeEventListener("click", clearLiveRegion);
      }
    };
    Announcer2.prototype.getLiveRegion = function(priority, ownerDocument) {
      var documentLiveRegions = this.liveRegions.get(ownerDocument);
      if (!documentLiveRegions) {
        documentLiveRegions = /* @__PURE__ */ new Map();
        this.liveRegions.set(ownerDocument, documentLiveRegions);
      }
      var existingLiveRegion = documentLiveRegions.get(priority);
      if (existingLiveRegion && ownerDocument.body.contains(existingLiveRegion)) {
        return existingLiveRegion;
      }
      var liveRegion = this.createLiveRegion(priority, ownerDocument);
      documentLiveRegions.set(priority, liveRegion);
      return liveRegion;
    };
    Announcer2.prototype.createLiveRegion = function(priority, ownerDocument) {
      var el = ownerDocument.createElement("div");
      el.style.position = "absolute";
      el.style.top = "-9999px";
      el.style.left = "-9999px";
      el.style.height = "1px";
      el.style.overflow = "hidden";
      el.setAttribute("aria-atomic", "true");
      el.setAttribute("aria-live", priority);
      el.setAttribute(DATA_MDC_DOM_ANNOUNCE, "true");
      ownerDocument.body.appendChild(el);
      return el;
    };
    return Announcer2;
  }()
);

// node_modules/@material/chips/chip-set/constants.js
var MDCChipSetAttributes;
(function(MDCChipSetAttributes2) {
  MDCChipSetAttributes2["ARIA_MULTISELECTABLE"] = "aria-multiselectable";
})(MDCChipSetAttributes || (MDCChipSetAttributes = {}));
var MDCChipSetCssClasses;
(function(MDCChipSetCssClasses2) {
  MDCChipSetCssClasses2["CHIP"] = "mdc-evolution-chip";
})(MDCChipSetCssClasses || (MDCChipSetCssClasses = {}));
var MDCChipSetEvents;
(function(MDCChipSetEvents2) {
  MDCChipSetEvents2["INTERACTION"] = "MDCChipSet:interaction";
  MDCChipSetEvents2["REMOVAL"] = "MDCChipSet:removal";
  MDCChipSetEvents2["SELECTION"] = "MDCChipSet:selection";
})(MDCChipSetEvents || (MDCChipSetEvents = {}));

// node_modules/@material/chips/chip-set/foundation.js
var Operator;
(function(Operator2) {
  Operator2[Operator2["INCREMENT"] = 0] = "INCREMENT";
  Operator2[Operator2["DECREMENT"] = 1] = "DECREMENT";
})(Operator || (Operator = {}));
var MDCChipSetFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCChipSetFoundation3, _super);
    function MDCChipSetFoundation3(adapter) {
      return _super.call(this, __assign(__assign({}, MDCChipSetFoundation3.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCChipSetFoundation3, "defaultAdapter", {
      get: function() {
        return {
          announceMessage: function() {
            return void 0;
          },
          emitEvent: function() {
            return void 0;
          },
          getAttribute: function() {
            return null;
          },
          getChipActionsAtIndex: function() {
            return [];
          },
          getChipCount: function() {
            return 0;
          },
          getChipIdAtIndex: function() {
            return "";
          },
          getChipIndexById: function() {
            return 0;
          },
          isChipFocusableAtIndex: function() {
            return false;
          },
          isChipSelectableAtIndex: function() {
            return false;
          },
          isChipSelectedAtIndex: function() {
            return false;
          },
          removeChipAtIndex: function() {
          },
          setChipFocusAtIndex: function() {
            return void 0;
          },
          setChipSelectedAtIndex: function() {
            return void 0;
          },
          startChipAnimationAtIndex: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCChipSetFoundation3.prototype.handleChipAnimation = function(_a2) {
      var detail = _a2.detail;
      var chipID = detail.chipID, animation = detail.animation, isComplete = detail.isComplete, addedAnnouncement = detail.addedAnnouncement, removedAnnouncement = detail.removedAnnouncement;
      var index = this.adapter.getChipIndexById(chipID);
      if (animation === MDCChipAnimation.EXIT && isComplete) {
        if (removedAnnouncement) {
          this.adapter.announceMessage(removedAnnouncement);
        }
        this.removeAfterAnimation(index, chipID);
        return;
      }
      if (animation === MDCChipAnimation.ENTER && isComplete && addedAnnouncement) {
        this.adapter.announceMessage(addedAnnouncement);
        return;
      }
    };
    MDCChipSetFoundation3.prototype.handleChipInteraction = function(_a2) {
      var detail = _a2.detail;
      var source = detail.source, chipID = detail.chipID, isSelectable = detail.isSelectable, isSelected = detail.isSelected, shouldRemove = detail.shouldRemove;
      var index = this.adapter.getChipIndexById(chipID);
      if (shouldRemove) {
        this.removeChip(index);
        return;
      }
      this.focusChip(index, source, MDCChipActionFocusBehavior.FOCUSABLE);
      this.adapter.emitEvent(MDCChipSetEvents.INTERACTION, {
        chipIndex: index,
        chipID
      });
      if (isSelectable) {
        this.setSelection(index, source, !isSelected);
      }
    };
    MDCChipSetFoundation3.prototype.handleChipNavigation = function(_a2) {
      var detail = _a2.detail;
      var chipID = detail.chipID, key = detail.key, isRTL = detail.isRTL, source = detail.source;
      var index = this.adapter.getChipIndexById(chipID);
      var toNextChip = key === KEY.ARROW_RIGHT && !isRTL || key === KEY.ARROW_LEFT && isRTL;
      if (toNextChip) {
        this.focusNextChipFrom(index + 1);
        return;
      }
      var toPreviousChip = key === KEY.ARROW_LEFT && !isRTL || key === KEY.ARROW_RIGHT && isRTL;
      if (toPreviousChip) {
        this.focusPrevChipFrom(index - 1);
        return;
      }
      if (key === KEY.ARROW_DOWN) {
        this.focusNextChipFrom(index + 1, source);
        return;
      }
      if (key === KEY.ARROW_UP) {
        this.focusPrevChipFrom(index - 1, source);
        return;
      }
      if (key === KEY.HOME) {
        this.focusNextChipFrom(0, source);
        return;
      }
      if (key === KEY.END) {
        this.focusPrevChipFrom(this.adapter.getChipCount() - 1, source);
        return;
      }
    };
    MDCChipSetFoundation3.prototype.getSelectedChipIndexes = function() {
      var e_1, _a2;
      var selectedIndexes = /* @__PURE__ */ new Set();
      var chipCount = this.adapter.getChipCount();
      for (var i = 0; i < chipCount; i++) {
        var actions = this.adapter.getChipActionsAtIndex(i);
        try {
          for (var actions_1 = (e_1 = void 0, __values(actions)), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {
            var action = actions_1_1.value;
            if (this.adapter.isChipSelectedAtIndex(i, action)) {
              selectedIndexes.add(i);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (actions_1_1 && !actions_1_1.done && (_a2 = actions_1.return))
              _a2.call(actions_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
      return selectedIndexes;
    };
    MDCChipSetFoundation3.prototype.setChipSelected = function(index, action, isSelected) {
      if (this.adapter.isChipSelectableAtIndex(index, action)) {
        this.setSelection(index, action, isSelected);
      }
    };
    MDCChipSetFoundation3.prototype.isChipSelected = function(index, action) {
      return this.adapter.isChipSelectedAtIndex(index, action);
    };
    MDCChipSetFoundation3.prototype.removeChip = function(index) {
      if (index >= this.adapter.getChipCount() || index < 0)
        return;
      this.adapter.startChipAnimationAtIndex(index, MDCChipAnimation.EXIT);
      this.adapter.emitEvent(MDCChipSetEvents.REMOVAL, {
        chipID: this.adapter.getChipIdAtIndex(index),
        chipIndex: index,
        isComplete: false
      });
    };
    MDCChipSetFoundation3.prototype.addChip = function(index) {
      if (index >= this.adapter.getChipCount() || index < 0)
        return;
      this.adapter.startChipAnimationAtIndex(index, MDCChipAnimation.ENTER);
    };
    MDCChipSetFoundation3.prototype.focusNextChipFrom = function(startIndex, targetAction) {
      var chipCount = this.adapter.getChipCount();
      for (var i = startIndex; i < chipCount; i++) {
        var focusableAction = this.getFocusableAction(i, Operator.INCREMENT, targetAction);
        if (focusableAction) {
          this.focusChip(i, focusableAction, MDCChipActionFocusBehavior.FOCUSABLE_AND_FOCUSED);
          return;
        }
      }
    };
    MDCChipSetFoundation3.prototype.focusPrevChipFrom = function(startIndex, targetAction) {
      for (var i = startIndex; i > -1; i--) {
        var focusableAction = this.getFocusableAction(i, Operator.DECREMENT, targetAction);
        if (focusableAction) {
          this.focusChip(i, focusableAction, MDCChipActionFocusBehavior.FOCUSABLE_AND_FOCUSED);
          return;
        }
      }
    };
    MDCChipSetFoundation3.prototype.getFocusableAction = function(index, op, targetAction) {
      var actions = this.adapter.getChipActionsAtIndex(index);
      if (op === Operator.DECREMENT)
        actions.reverse();
      if (targetAction) {
        return this.getMatchingFocusableAction(index, actions, targetAction);
      }
      return this.getFirstFocusableAction(index, actions);
    };
    MDCChipSetFoundation3.prototype.getFirstFocusableAction = function(index, actions) {
      var e_2, _a2;
      try {
        for (var actions_2 = __values(actions), actions_2_1 = actions_2.next(); !actions_2_1.done; actions_2_1 = actions_2.next()) {
          var action = actions_2_1.value;
          if (this.adapter.isChipFocusableAtIndex(index, action)) {
            return action;
          }
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (actions_2_1 && !actions_2_1.done && (_a2 = actions_2.return))
            _a2.call(actions_2);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      return null;
    };
    MDCChipSetFoundation3.prototype.getMatchingFocusableAction = function(index, actions, targetAction) {
      var e_3, _a2;
      var focusableAction = null;
      try {
        for (var actions_3 = __values(actions), actions_3_1 = actions_3.next(); !actions_3_1.done; actions_3_1 = actions_3.next()) {
          var action = actions_3_1.value;
          if (this.adapter.isChipFocusableAtIndex(index, action)) {
            focusableAction = action;
          }
          if (focusableAction === targetAction) {
            return focusableAction;
          }
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (actions_3_1 && !actions_3_1.done && (_a2 = actions_3.return))
            _a2.call(actions_3);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      return focusableAction;
    };
    MDCChipSetFoundation3.prototype.focusChip = function(index, action, focus) {
      var e_4, _a2;
      this.adapter.setChipFocusAtIndex(index, action, focus);
      var chipCount = this.adapter.getChipCount();
      for (var i = 0; i < chipCount; i++) {
        var actions = this.adapter.getChipActionsAtIndex(i);
        try {
          for (var actions_4 = (e_4 = void 0, __values(actions)), actions_4_1 = actions_4.next(); !actions_4_1.done; actions_4_1 = actions_4.next()) {
            var chipAction = actions_4_1.value;
            if (chipAction === action && i === index)
              continue;
            this.adapter.setChipFocusAtIndex(i, chipAction, MDCChipActionFocusBehavior.NOT_FOCUSABLE);
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (actions_4_1 && !actions_4_1.done && (_a2 = actions_4.return))
              _a2.call(actions_4);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
      }
    };
    MDCChipSetFoundation3.prototype.supportsMultiSelect = function() {
      return this.adapter.getAttribute(MDCChipSetAttributes.ARIA_MULTISELECTABLE) === "true";
    };
    MDCChipSetFoundation3.prototype.setSelection = function(index, action, isSelected) {
      var e_5, _a2;
      this.adapter.setChipSelectedAtIndex(index, action, isSelected);
      this.adapter.emitEvent(MDCChipSetEvents.SELECTION, {
        chipID: this.adapter.getChipIdAtIndex(index),
        chipIndex: index,
        isSelected
      });
      if (this.supportsMultiSelect()) {
        return;
      }
      var chipCount = this.adapter.getChipCount();
      for (var i = 0; i < chipCount; i++) {
        var actions = this.adapter.getChipActionsAtIndex(i);
        try {
          for (var actions_5 = (e_5 = void 0, __values(actions)), actions_5_1 = actions_5.next(); !actions_5_1.done; actions_5_1 = actions_5.next()) {
            var chipAction = actions_5_1.value;
            if (chipAction === action && i === index)
              continue;
            this.adapter.setChipSelectedAtIndex(i, chipAction, false);
          }
        } catch (e_5_1) {
          e_5 = { error: e_5_1 };
        } finally {
          try {
            if (actions_5_1 && !actions_5_1.done && (_a2 = actions_5.return))
              _a2.call(actions_5);
          } finally {
            if (e_5)
              throw e_5.error;
          }
        }
      }
    };
    MDCChipSetFoundation3.prototype.removeAfterAnimation = function(index, chipID) {
      this.adapter.removeChipAtIndex(index);
      this.adapter.emitEvent(MDCChipSetEvents.REMOVAL, {
        chipIndex: index,
        isComplete: true,
        chipID
      });
      var chipCount = this.adapter.getChipCount();
      if (chipCount <= 0)
        return;
      this.focusNearestFocusableAction(index);
    };
    MDCChipSetFoundation3.prototype.focusNearestFocusableAction = function(index) {
      var chipCount = this.adapter.getChipCount();
      var decrIndex = index;
      var incrIndex = index;
      while (decrIndex > -1 || incrIndex < chipCount) {
        var focusAction = this.getNearestFocusableAction(decrIndex, incrIndex, MDCChipActionType.TRAILING);
        if (focusAction) {
          this.focusChip(focusAction.index, focusAction.action, MDCChipActionFocusBehavior.FOCUSABLE_AND_FOCUSED);
          return;
        }
        decrIndex--;
        incrIndex++;
      }
    };
    MDCChipSetFoundation3.prototype.getNearestFocusableAction = function(decrIndex, incrIndex, actionType) {
      var decrAction = this.getFocusableAction(decrIndex, Operator.DECREMENT, actionType);
      if (decrAction) {
        return {
          index: decrIndex,
          action: decrAction
        };
      }
      if (incrIndex === decrIndex)
        return null;
      var incrAction = this.getFocusableAction(incrIndex, Operator.INCREMENT, actionType);
      if (incrAction) {
        return {
          index: incrIndex,
          action: incrAction
        };
      }
      return null;
    };
    return MDCChipSetFoundation3;
  }(MDCFoundation)
);

// node_modules/@material/chips/chip-set/component.js
var MDCChipSet = (
  /** @class */
  function(_super) {
    __extends(MDCChipSet3, _super);
    function MDCChipSet3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCChipSet3.attachTo = function(root) {
      return new MDCChipSet3(root);
    };
    MDCChipSet3.prototype.initialize = function(chipFactory) {
      if (chipFactory === void 0) {
        chipFactory = function(el) {
          return new MDCChip(el);
        };
      }
      this.chips = [];
      var chipEls = this.root.querySelectorAll("." + MDCChipSetCssClasses.CHIP);
      for (var i = 0; i < chipEls.length; i++) {
        var chip = chipFactory(chipEls[i]);
        this.chips.push(chip);
      }
    };
    MDCChipSet3.prototype.initialSyncWithDOM = function() {
      var _this = this;
      this.handleChipAnimation = function(event) {
        _this.foundation.handleChipAnimation(event);
      };
      this.handleChipInteraction = function(event) {
        _this.foundation.handleChipInteraction(event);
      };
      this.handleChipNavigation = function(event) {
        _this.foundation.handleChipNavigation(event);
      };
      this.listen(MDCChipEvents.ANIMATION, this.handleChipAnimation);
      this.listen(MDCChipEvents.INTERACTION, this.handleChipInteraction);
      this.listen(MDCChipEvents.NAVIGATION, this.handleChipNavigation);
    };
    MDCChipSet3.prototype.destroy = function() {
      this.unlisten(MDCChipEvents.ANIMATION, this.handleChipAnimation);
      this.unlisten(MDCChipEvents.INTERACTION, this.handleChipInteraction);
      this.unlisten(MDCChipEvents.NAVIGATION, this.handleChipNavigation);
      _super.prototype.destroy.call(this);
    };
    MDCChipSet3.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        announceMessage: function(message) {
          announce2(message);
        },
        emitEvent: function(eventName, eventDetail) {
          _this.emit(
            eventName,
            eventDetail,
            true
            /* shouldBubble */
          );
        },
        getAttribute: function(attrName) {
          return _this.root.getAttribute(attrName);
        },
        getChipActionsAtIndex: function(index) {
          if (!_this.isIndexValid(index))
            return [];
          return _this.chips[index].getActions();
        },
        getChipCount: function() {
          return _this.chips.length;
        },
        getChipIdAtIndex: function(index) {
          if (!_this.isIndexValid(index))
            return "";
          return _this.chips[index].getElementID();
        },
        getChipIndexById: function(id) {
          return _this.chips.findIndex(function(chip) {
            return chip.getElementID() === id;
          });
        },
        isChipFocusableAtIndex: function(index, action) {
          if (!_this.isIndexValid(index))
            return false;
          return _this.chips[index].isActionFocusable(action);
        },
        isChipSelectableAtIndex: function(index, action) {
          if (!_this.isIndexValid(index))
            return false;
          return _this.chips[index].isActionSelectable(action);
        },
        isChipSelectedAtIndex: function(index, action) {
          if (!_this.isIndexValid(index))
            return false;
          return _this.chips[index].isActionSelected(action);
        },
        removeChipAtIndex: function(index) {
          if (!_this.isIndexValid(index))
            return;
          _this.chips[index].destroy();
          _this.chips[index].remove();
          _this.chips.splice(index, 1);
        },
        setChipFocusAtIndex: function(index, action, focus) {
          if (!_this.isIndexValid(index))
            return;
          _this.chips[index].setActionFocus(action, focus);
        },
        setChipSelectedAtIndex: function(index, action, selected) {
          if (!_this.isIndexValid(index))
            return;
          _this.chips[index].setActionSelected(action, selected);
        },
        startChipAnimationAtIndex: function(index, animation) {
          if (!_this.isIndexValid(index))
            return;
          _this.chips[index].startAnimation(animation);
        }
      };
      return new MDCChipSetFoundation(adapter);
    };
    MDCChipSet3.prototype.getChipIndexByID = function(chipID) {
      return this.chips.findIndex(function(chip) {
        return chip.getElementID() === chipID;
      });
    };
    MDCChipSet3.prototype.getChipIdAtIndex = function(index) {
      if (!this.isIndexValid(index))
        return "";
      return this.chips[index].getElementID();
    };
    MDCChipSet3.prototype.getSelectedChipIndexes = function() {
      return this.foundation.getSelectedChipIndexes();
    };
    MDCChipSet3.prototype.setChipSelected = function(index, action, isSelected) {
      this.foundation.setChipSelected(index, action, isSelected);
    };
    MDCChipSet3.prototype.isChipSelected = function(index, action) {
      return this.foundation.isChipSelected(index, action);
    };
    MDCChipSet3.prototype.addChip = function(index) {
      this.foundation.addChip(index);
    };
    MDCChipSet3.prototype.removeChip = function(index) {
      this.foundation.removeChip(index);
    };
    MDCChipSet3.prototype.isIndexValid = function(index) {
      return index > -1 && index < this.chips.length;
    };
    return MDCChipSet3;
  }(MDCComponent)
);

// node_modules/@material/chips/deprecated/index.js
var deprecated_exports = {};
__export(deprecated_exports, {
  MDCChip: () => MDCChip2,
  MDCChipFoundation: () => MDCChipFoundation2,
  MDCChipSet: () => MDCChipSet2,
  MDCChipSetFoundation: () => MDCChipSetFoundation2,
  MDCChipTrailingAction: () => MDCChipTrailingAction,
  MDCChipTrailingActionFoundation: () => MDCChipTrailingActionFoundation2,
  chipCssClasses: () => cssClasses,
  chipSetCssClasses: () => cssClasses2,
  chipSetStrings: () => strings3,
  chipStrings: () => strings2,
  trailingActionStrings: () => strings
});

// node_modules/@material/chips/deprecated/trailingaction/constants.js
var InteractionTrigger;
(function(InteractionTrigger2) {
  InteractionTrigger2[InteractionTrigger2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  InteractionTrigger2[InteractionTrigger2["CLICK"] = 1] = "CLICK";
  InteractionTrigger2[InteractionTrigger2["BACKSPACE_KEY"] = 2] = "BACKSPACE_KEY";
  InteractionTrigger2[InteractionTrigger2["DELETE_KEY"] = 3] = "DELETE_KEY";
  InteractionTrigger2[InteractionTrigger2["SPACEBAR_KEY"] = 4] = "SPACEBAR_KEY";
  InteractionTrigger2[InteractionTrigger2["ENTER_KEY"] = 5] = "ENTER_KEY";
})(InteractionTrigger || (InteractionTrigger = {}));
var strings = {
  ARIA_HIDDEN: "aria-hidden",
  INTERACTION_EVENT: "MDCChipTrailingAction:interaction",
  NAVIGATION_EVENT: "MDCChipTrailingAction:navigation",
  TAB_INDEX: "tabindex"
};

// node_modules/@material/chips/deprecated/trailingaction/foundation.js
var MDCChipTrailingActionFoundation2 = (
  /** @class */
  function(_super) {
    __extends(MDCChipTrailingActionFoundation3, _super);
    function MDCChipTrailingActionFoundation3(adapter) {
      return _super.call(this, __assign(__assign({}, MDCChipTrailingActionFoundation3.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCChipTrailingActionFoundation3, "strings", {
      get: function() {
        return strings;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCChipTrailingActionFoundation3, "defaultAdapter", {
      get: function() {
        return {
          focus: function() {
            return void 0;
          },
          getAttribute: function() {
            return null;
          },
          setAttribute: function() {
            return void 0;
          },
          notifyInteraction: function() {
            return void 0;
          },
          notifyNavigation: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCChipTrailingActionFoundation3.prototype.handleClick = function(evt) {
      evt.stopPropagation();
      this.adapter.notifyInteraction(InteractionTrigger.CLICK);
    };
    MDCChipTrailingActionFoundation3.prototype.handleKeydown = function(evt) {
      evt.stopPropagation();
      var key = normalizeKey(evt);
      if (this.shouldNotifyInteractionFromKey(key)) {
        var trigger = this.getTriggerFromKey(key);
        this.adapter.notifyInteraction(trigger);
        return;
      }
      if (isNavigationEvent(evt)) {
        this.adapter.notifyNavigation(key);
        return;
      }
    };
    MDCChipTrailingActionFoundation3.prototype.removeFocus = function() {
      this.adapter.setAttribute(strings.TAB_INDEX, "-1");
    };
    MDCChipTrailingActionFoundation3.prototype.focus = function() {
      this.adapter.setAttribute(strings.TAB_INDEX, "0");
      this.adapter.focus();
    };
    MDCChipTrailingActionFoundation3.prototype.isNavigable = function() {
      return this.adapter.getAttribute(strings.ARIA_HIDDEN) !== "true";
    };
    MDCChipTrailingActionFoundation3.prototype.shouldNotifyInteractionFromKey = function(key) {
      var isFromActionKey = key === KEY.ENTER || key === KEY.SPACEBAR;
      var isFromDeleteKey = key === KEY.BACKSPACE || key === KEY.DELETE;
      return isFromActionKey || isFromDeleteKey;
    };
    MDCChipTrailingActionFoundation3.prototype.getTriggerFromKey = function(key) {
      if (key === KEY.SPACEBAR) {
        return InteractionTrigger.SPACEBAR_KEY;
      }
      if (key === KEY.ENTER) {
        return InteractionTrigger.ENTER_KEY;
      }
      if (key === KEY.DELETE) {
        return InteractionTrigger.DELETE_KEY;
      }
      if (key === KEY.BACKSPACE) {
        return InteractionTrigger.BACKSPACE_KEY;
      }
      return InteractionTrigger.UNSPECIFIED;
    };
    return MDCChipTrailingActionFoundation3;
  }(MDCFoundation)
);

// node_modules/@material/chips/deprecated/trailingaction/component.js
var MDCChipTrailingAction = (
  /** @class */
  function(_super) {
    __extends(MDCChipTrailingAction2, _super);
    function MDCChipTrailingAction2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(MDCChipTrailingAction2.prototype, "ripple", {
      get: function() {
        return this.rippleSurface;
      },
      enumerable: false,
      configurable: true
    });
    MDCChipTrailingAction2.attachTo = function(root) {
      return new MDCChipTrailingAction2(root);
    };
    MDCChipTrailingAction2.prototype.initialize = function(rippleFactory) {
      if (rippleFactory === void 0) {
        rippleFactory = function(el, foundation) {
          return new MDCRipple(el, foundation);
        };
      }
      var rippleAdapter = MDCRipple.createAdapter(this);
      this.rippleSurface = rippleFactory(this.root, new MDCRippleFoundation(rippleAdapter));
    };
    MDCChipTrailingAction2.prototype.initialSyncWithDOM = function() {
      var _this = this;
      this.handleClick = function(evt) {
        _this.foundation.handleClick(evt);
      };
      this.handleKeydown = function(evt) {
        _this.foundation.handleKeydown(evt);
      };
      this.listen("click", this.handleClick);
      this.listen("keydown", this.handleKeydown);
    };
    MDCChipTrailingAction2.prototype.destroy = function() {
      this.rippleSurface.destroy();
      this.unlisten("click", this.handleClick);
      this.unlisten("keydown", this.handleKeydown);
      _super.prototype.destroy.call(this);
    };
    MDCChipTrailingAction2.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        focus: function() {
          _this.root.focus();
        },
        getAttribute: function(attr) {
          return _this.root.getAttribute(attr);
        },
        notifyInteraction: function(trigger) {
          return _this.emit(
            strings.INTERACTION_EVENT,
            { trigger },
            true
            /* shouldBubble */
          );
        },
        notifyNavigation: function(key) {
          _this.emit(
            strings.NAVIGATION_EVENT,
            { key },
            true
            /* shouldBubble */
          );
        },
        setAttribute: function(attr, value) {
          _this.root.setAttribute(attr, value);
        }
      };
      return new MDCChipTrailingActionFoundation2(adapter);
    };
    MDCChipTrailingAction2.prototype.isNavigable = function() {
      return this.foundation.isNavigable();
    };
    MDCChipTrailingAction2.prototype.focus = function() {
      this.foundation.focus();
    };
    MDCChipTrailingAction2.prototype.removeFocus = function() {
      this.foundation.removeFocus();
    };
    return MDCChipTrailingAction2;
  }(MDCComponent)
);

// node_modules/@material/chips/deprecated/chip/constants.js
var Direction2;
(function(Direction3) {
  Direction3["LEFT"] = "left";
  Direction3["RIGHT"] = "right";
})(Direction2 || (Direction2 = {}));
var EventSource;
(function(EventSource2) {
  EventSource2["PRIMARY"] = "primary";
  EventSource2["TRAILING"] = "trailing";
  EventSource2["NONE"] = "none";
})(EventSource || (EventSource = {}));
var strings2 = {
  ADDED_ANNOUNCEMENT_ATTRIBUTE: "data-mdc-chip-added-announcement",
  ARIA_CHECKED: "aria-checked",
  ARROW_DOWN_KEY: "ArrowDown",
  ARROW_LEFT_KEY: "ArrowLeft",
  ARROW_RIGHT_KEY: "ArrowRight",
  ARROW_UP_KEY: "ArrowUp",
  BACKSPACE_KEY: "Backspace",
  CHECKMARK_SELECTOR: ".mdc-chip__checkmark",
  DELETE_KEY: "Delete",
  END_KEY: "End",
  ENTER_KEY: "Enter",
  ENTRY_ANIMATION_NAME: "mdc-chip-entry",
  HOME_KEY: "Home",
  IE_ARROW_DOWN_KEY: "Down",
  IE_ARROW_LEFT_KEY: "Left",
  IE_ARROW_RIGHT_KEY: "Right",
  IE_ARROW_UP_KEY: "Up",
  IE_DELETE_KEY: "Del",
  INTERACTION_EVENT: "MDCChip:interaction",
  LEADING_ICON_SELECTOR: ".mdc-chip__icon--leading",
  NAVIGATION_EVENT: "MDCChip:navigation",
  PRIMARY_ACTION_SELECTOR: ".mdc-chip__primary-action",
  REMOVED_ANNOUNCEMENT_ATTRIBUTE: "data-mdc-chip-removed-announcement",
  REMOVAL_EVENT: "MDCChip:removal",
  SELECTION_EVENT: "MDCChip:selection",
  SPACEBAR_KEY: " ",
  TAB_INDEX: "tabindex",
  TRAILING_ACTION_SELECTOR: ".mdc-chip-trailing-action",
  TRAILING_ICON_INTERACTION_EVENT: "MDCChip:trailingIconInteraction",
  TRAILING_ICON_SELECTOR: ".mdc-chip__icon--trailing"
};
var cssClasses = {
  CHECKMARK: "mdc-chip__checkmark",
  CHIP_EXIT: "mdc-chip--exit",
  DELETABLE: "mdc-chip--deletable",
  EDITABLE: "mdc-chip--editable",
  EDITING: "mdc-chip--editing",
  HIDDEN_LEADING_ICON: "mdc-chip__icon--leading-hidden",
  LEADING_ICON: "mdc-chip__icon--leading",
  PRIMARY_ACTION: "mdc-chip__primary-action",
  PRIMARY_ACTION_FOCUSED: "mdc-chip--primary-action-focused",
  SELECTED: "mdc-chip--selected",
  TEXT: "mdc-chip__text",
  TRAILING_ACTION: "mdc-chip__trailing-action",
  TRAILING_ICON: "mdc-chip__icon--trailing"
};
var navigationKeys = /* @__PURE__ */ new Set();
navigationKeys.add(strings2.ARROW_LEFT_KEY);
navigationKeys.add(strings2.ARROW_RIGHT_KEY);
navigationKeys.add(strings2.ARROW_DOWN_KEY);
navigationKeys.add(strings2.ARROW_UP_KEY);
navigationKeys.add(strings2.END_KEY);
navigationKeys.add(strings2.HOME_KEY);
navigationKeys.add(strings2.IE_ARROW_LEFT_KEY);
navigationKeys.add(strings2.IE_ARROW_RIGHT_KEY);
navigationKeys.add(strings2.IE_ARROW_DOWN_KEY);
navigationKeys.add(strings2.IE_ARROW_UP_KEY);
var jumpChipKeys = /* @__PURE__ */ new Set();
jumpChipKeys.add(strings2.ARROW_UP_KEY);
jumpChipKeys.add(strings2.ARROW_DOWN_KEY);
jumpChipKeys.add(strings2.HOME_KEY);
jumpChipKeys.add(strings2.END_KEY);
jumpChipKeys.add(strings2.IE_ARROW_UP_KEY);
jumpChipKeys.add(strings2.IE_ARROW_DOWN_KEY);

// node_modules/@material/chips/deprecated/chip/foundation.js
var emptyClientRect = {
  bottom: 0,
  height: 0,
  left: 0,
  right: 0,
  top: 0,
  width: 0
};
var FocusBehavior;
(function(FocusBehavior2) {
  FocusBehavior2[FocusBehavior2["SHOULD_FOCUS"] = 0] = "SHOULD_FOCUS";
  FocusBehavior2[FocusBehavior2["SHOULD_NOT_FOCUS"] = 1] = "SHOULD_NOT_FOCUS";
})(FocusBehavior || (FocusBehavior = {}));
var MDCChipFoundation2 = (
  /** @class */
  function(_super) {
    __extends(MDCChipFoundation3, _super);
    function MDCChipFoundation3(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCChipFoundation3.defaultAdapter), adapter)) || this;
      _this.shouldRemoveOnTrailingIconClick = true;
      _this.shouldFocusPrimaryActionOnClick = true;
      return _this;
    }
    Object.defineProperty(MDCChipFoundation3, "strings", {
      get: function() {
        return strings2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCChipFoundation3, "cssClasses", {
      get: function() {
        return cssClasses;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCChipFoundation3, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          addClassToLeadingIcon: function() {
            return void 0;
          },
          eventTargetHasClass: function() {
            return false;
          },
          focusPrimaryAction: function() {
            return void 0;
          },
          focusTrailingAction: function() {
            return void 0;
          },
          getAttribute: function() {
            return null;
          },
          getCheckmarkBoundingClientRect: function() {
            return emptyClientRect;
          },
          getComputedStyleValue: function() {
            return "";
          },
          getRootBoundingClientRect: function() {
            return emptyClientRect;
          },
          hasClass: function() {
            return false;
          },
          hasLeadingIcon: function() {
            return false;
          },
          isRTL: function() {
            return false;
          },
          isTrailingActionNavigable: function() {
            return false;
          },
          notifyEditFinish: function() {
            return void 0;
          },
          notifyEditStart: function() {
            return void 0;
          },
          notifyInteraction: function() {
            return void 0;
          },
          notifyNavigation: function() {
            return void 0;
          },
          notifyRemoval: function() {
            return void 0;
          },
          notifySelection: function() {
            return void 0;
          },
          notifyTrailingIconInteraction: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          removeClassFromLeadingIcon: function() {
            return void 0;
          },
          removeTrailingActionFocus: function() {
            return void 0;
          },
          setPrimaryActionAttr: function() {
            return void 0;
          },
          setStyleProperty: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCChipFoundation3.prototype.isSelected = function() {
      return this.adapter.hasClass(cssClasses.SELECTED);
    };
    MDCChipFoundation3.prototype.isEditable = function() {
      return this.adapter.hasClass(cssClasses.EDITABLE);
    };
    MDCChipFoundation3.prototype.isEditing = function() {
      return this.adapter.hasClass(cssClasses.EDITING);
    };
    MDCChipFoundation3.prototype.setSelected = function(selected) {
      this.setSelectedImpl(selected);
      this.notifySelection(selected);
    };
    MDCChipFoundation3.prototype.setSelectedFromChipSet = function(selected, shouldNotifyClients) {
      this.setSelectedImpl(selected);
      if (shouldNotifyClients) {
        this.notifyIgnoredSelection(selected);
      }
    };
    MDCChipFoundation3.prototype.getShouldRemoveOnTrailingIconClick = function() {
      return this.shouldRemoveOnTrailingIconClick;
    };
    MDCChipFoundation3.prototype.setShouldRemoveOnTrailingIconClick = function(shouldRemove) {
      this.shouldRemoveOnTrailingIconClick = shouldRemove;
    };
    MDCChipFoundation3.prototype.setShouldFocusPrimaryActionOnClick = function(shouldFocus) {
      this.shouldFocusPrimaryActionOnClick = shouldFocus;
    };
    MDCChipFoundation3.prototype.getDimensions = function() {
      var _this = this;
      var getRootRect = function() {
        return _this.adapter.getRootBoundingClientRect();
      };
      var getCheckmarkRect = function() {
        return _this.adapter.getCheckmarkBoundingClientRect();
      };
      if (!this.adapter.hasLeadingIcon()) {
        var checkmarkRect = getCheckmarkRect();
        if (checkmarkRect) {
          var rootRect = getRootRect();
          return {
            bottom: rootRect.bottom,
            height: rootRect.height,
            left: rootRect.left,
            right: rootRect.right,
            top: rootRect.top,
            width: rootRect.width + checkmarkRect.height
          };
        }
      }
      return getRootRect();
    };
    MDCChipFoundation3.prototype.beginExit = function() {
      this.adapter.addClass(cssClasses.CHIP_EXIT);
    };
    MDCChipFoundation3.prototype.handleClick = function() {
      this.adapter.notifyInteraction();
      this.setPrimaryActionFocusable(this.getFocusBehavior());
    };
    MDCChipFoundation3.prototype.handleDoubleClick = function() {
      if (this.isEditable()) {
        this.startEditing();
      }
    };
    MDCChipFoundation3.prototype.handleTransitionEnd = function(evt) {
      var _this = this;
      var shouldHandle = this.adapter.eventTargetHasClass(evt.target, cssClasses.CHIP_EXIT);
      var widthIsAnimating = evt.propertyName === "width";
      var opacityIsAnimating = evt.propertyName === "opacity";
      if (shouldHandle && opacityIsAnimating) {
        var chipWidth_1 = this.adapter.getComputedStyleValue("width");
        requestAnimationFrame(function() {
          _this.adapter.setStyleProperty("width", chipWidth_1);
          _this.adapter.setStyleProperty("padding", "0");
          _this.adapter.setStyleProperty("margin", "0");
          requestAnimationFrame(function() {
            _this.adapter.setStyleProperty("width", "0");
          });
        });
        return;
      }
      if (shouldHandle && widthIsAnimating) {
        this.removeFocus();
        var removedAnnouncement = this.adapter.getAttribute(strings2.REMOVED_ANNOUNCEMENT_ATTRIBUTE);
        this.adapter.notifyRemoval(removedAnnouncement);
      }
      if (!opacityIsAnimating) {
        return;
      }
      var shouldHideLeadingIcon = this.adapter.eventTargetHasClass(evt.target, cssClasses.LEADING_ICON) && this.adapter.hasClass(cssClasses.SELECTED);
      var shouldShowLeadingIcon = this.adapter.eventTargetHasClass(evt.target, cssClasses.CHECKMARK) && !this.adapter.hasClass(cssClasses.SELECTED);
      if (shouldHideLeadingIcon) {
        this.adapter.addClassToLeadingIcon(cssClasses.HIDDEN_LEADING_ICON);
        return;
      }
      if (shouldShowLeadingIcon) {
        this.adapter.removeClassFromLeadingIcon(cssClasses.HIDDEN_LEADING_ICON);
        return;
      }
    };
    MDCChipFoundation3.prototype.handleFocusIn = function(evt) {
      if (!this.eventFromPrimaryAction(evt)) {
        return;
      }
      this.adapter.addClass(cssClasses.PRIMARY_ACTION_FOCUSED);
    };
    MDCChipFoundation3.prototype.handleFocusOut = function(evt) {
      if (!this.eventFromPrimaryAction(evt)) {
        return;
      }
      if (this.isEditing()) {
        this.finishEditing();
      }
      this.adapter.removeClass(cssClasses.PRIMARY_ACTION_FOCUSED);
    };
    MDCChipFoundation3.prototype.handleTrailingActionInteraction = function() {
      this.adapter.notifyTrailingIconInteraction();
      this.removeChip();
    };
    MDCChipFoundation3.prototype.handleKeydown = function(evt) {
      if (this.isEditing()) {
        if (this.shouldFinishEditing(evt)) {
          evt.preventDefault();
          this.finishEditing();
        }
        return;
      }
      if (this.isEditable()) {
        if (this.shouldStartEditing(evt)) {
          evt.preventDefault();
          this.startEditing();
        }
      }
      if (this.shouldNotifyInteraction(evt)) {
        this.adapter.notifyInteraction();
        this.setPrimaryActionFocusable(this.getFocusBehavior());
        return;
      }
      if (this.isDeleteAction(evt)) {
        evt.preventDefault();
        this.removeChip();
        return;
      }
      if (!navigationKeys.has(evt.key)) {
        return;
      }
      evt.preventDefault();
      this.focusNextAction(evt.key, EventSource.PRIMARY);
    };
    MDCChipFoundation3.prototype.handleTrailingActionNavigation = function(evt) {
      this.focusNextAction(evt.detail.key, EventSource.TRAILING);
    };
    MDCChipFoundation3.prototype.removeFocus = function() {
      this.adapter.setPrimaryActionAttr(strings2.TAB_INDEX, "-1");
      this.adapter.removeTrailingActionFocus();
    };
    MDCChipFoundation3.prototype.focusPrimaryAction = function() {
      this.setPrimaryActionFocusable(FocusBehavior.SHOULD_FOCUS);
    };
    MDCChipFoundation3.prototype.focusTrailingAction = function() {
      var trailingActionIsNavigable = this.adapter.isTrailingActionNavigable();
      if (trailingActionIsNavigable) {
        this.adapter.setPrimaryActionAttr(strings2.TAB_INDEX, "-1");
        this.adapter.focusTrailingAction();
        return;
      }
      this.focusPrimaryAction();
    };
    MDCChipFoundation3.prototype.setPrimaryActionFocusable = function(focusBehavior) {
      this.adapter.setPrimaryActionAttr(strings2.TAB_INDEX, "0");
      if (focusBehavior === FocusBehavior.SHOULD_FOCUS) {
        this.adapter.focusPrimaryAction();
      }
      this.adapter.removeTrailingActionFocus();
    };
    MDCChipFoundation3.prototype.getFocusBehavior = function() {
      if (this.shouldFocusPrimaryActionOnClick) {
        return FocusBehavior.SHOULD_FOCUS;
      }
      return FocusBehavior.SHOULD_NOT_FOCUS;
    };
    MDCChipFoundation3.prototype.focusNextAction = function(key, source) {
      var isTrailingActionNavigable = this.adapter.isTrailingActionNavigable();
      var dir = this.getDirection(key);
      if (jumpChipKeys.has(key) || !isTrailingActionNavigable) {
        this.adapter.notifyNavigation(key, source);
        return;
      }
      if (source === EventSource.PRIMARY && dir === Direction2.RIGHT) {
        this.focusTrailingAction();
        return;
      }
      if (source === EventSource.TRAILING && dir === Direction2.LEFT) {
        this.focusPrimaryAction();
        return;
      }
      this.adapter.notifyNavigation(key, EventSource.NONE);
    };
    MDCChipFoundation3.prototype.getDirection = function(key) {
      var isRTL = this.adapter.isRTL();
      var isLeftKey = key === strings2.ARROW_LEFT_KEY || key === strings2.IE_ARROW_LEFT_KEY;
      var isRightKey = key === strings2.ARROW_RIGHT_KEY || key === strings2.IE_ARROW_RIGHT_KEY;
      if (!isRTL && isLeftKey || isRTL && isRightKey) {
        return Direction2.LEFT;
      }
      return Direction2.RIGHT;
    };
    MDCChipFoundation3.prototype.removeChip = function() {
      if (this.shouldRemoveOnTrailingIconClick) {
        this.beginExit();
      }
    };
    MDCChipFoundation3.prototype.shouldStartEditing = function(evt) {
      return this.eventFromPrimaryAction(evt) && evt.key === strings2.ENTER_KEY;
    };
    MDCChipFoundation3.prototype.shouldFinishEditing = function(evt) {
      return evt.key === strings2.ENTER_KEY;
    };
    MDCChipFoundation3.prototype.shouldNotifyInteraction = function(evt) {
      return evt.key === strings2.ENTER_KEY || evt.key === strings2.SPACEBAR_KEY;
    };
    MDCChipFoundation3.prototype.isDeleteAction = function(evt) {
      var isDeletable = this.adapter.hasClass(cssClasses.DELETABLE);
      return isDeletable && (evt.key === strings2.BACKSPACE_KEY || evt.key === strings2.DELETE_KEY || evt.key === strings2.IE_DELETE_KEY);
    };
    MDCChipFoundation3.prototype.setSelectedImpl = function(selected) {
      if (selected) {
        this.adapter.addClass(cssClasses.SELECTED);
        this.adapter.setPrimaryActionAttr(strings2.ARIA_CHECKED, "true");
      } else {
        this.adapter.removeClass(cssClasses.SELECTED);
        this.adapter.setPrimaryActionAttr(strings2.ARIA_CHECKED, "false");
      }
    };
    MDCChipFoundation3.prototype.notifySelection = function(selected) {
      this.adapter.notifySelection(selected, false);
    };
    MDCChipFoundation3.prototype.notifyIgnoredSelection = function(selected) {
      this.adapter.notifySelection(selected, true);
    };
    MDCChipFoundation3.prototype.eventFromPrimaryAction = function(evt) {
      return this.adapter.eventTargetHasClass(evt.target, cssClasses.PRIMARY_ACTION);
    };
    MDCChipFoundation3.prototype.startEditing = function() {
      this.adapter.addClass(cssClasses.EDITING);
      this.adapter.notifyEditStart();
    };
    MDCChipFoundation3.prototype.finishEditing = function() {
      this.adapter.removeClass(cssClasses.EDITING);
      this.adapter.notifyEditFinish();
    };
    return MDCChipFoundation3;
  }(MDCFoundation)
);

// node_modules/@material/chips/deprecated/chip/component.js
var MDCChip2 = (
  /** @class */
  function(_super) {
    __extends(MDCChip3, _super);
    function MDCChip3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(MDCChip3.prototype, "selected", {
      /**
       * @return Whether the chip is selected.
       */
      get: function() {
        return this.foundation.isSelected();
      },
      /**
       * Sets selected state on the chip.
       */
      set: function(selected) {
        this.foundation.setSelected(selected);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCChip3.prototype, "shouldRemoveOnTrailingIconClick", {
      /**
       * @return Whether a trailing icon click should trigger exit/removal of the chip.
       */
      get: function() {
        return this.foundation.getShouldRemoveOnTrailingIconClick();
      },
      /**
       * Sets whether a trailing icon click should trigger exit/removal of the chip.
       */
      set: function(shouldRemove) {
        this.foundation.setShouldRemoveOnTrailingIconClick(shouldRemove);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCChip3.prototype, "setShouldFocusPrimaryActionOnClick", {
      /**
       * Sets whether a clicking on the chip should focus the primary action.
       */
      set: function(shouldFocus) {
        this.foundation.setShouldFocusPrimaryActionOnClick(shouldFocus);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCChip3.prototype, "ripple", {
      get: function() {
        return this.rippleSurface;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCChip3.prototype, "id", {
      get: function() {
        return this.root.id;
      },
      enumerable: false,
      configurable: true
    });
    MDCChip3.attachTo = function(root) {
      return new MDCChip3(root);
    };
    MDCChip3.prototype.initialize = function(rippleFactory, trailingActionFactory) {
      var _this = this;
      if (rippleFactory === void 0) {
        rippleFactory = function(el, foundation) {
          return new MDCRipple(el, foundation);
        };
      }
      if (trailingActionFactory === void 0) {
        trailingActionFactory = function(el) {
          return new MDCChipTrailingAction(el);
        };
      }
      this.leadingIcon = this.root.querySelector(strings2.LEADING_ICON_SELECTOR);
      this.checkmark = this.root.querySelector(strings2.CHECKMARK_SELECTOR);
      this.primaryAction = this.root.querySelector(strings2.PRIMARY_ACTION_SELECTOR);
      var trailingActionEl = this.root.querySelector(strings2.TRAILING_ACTION_SELECTOR);
      if (trailingActionEl) {
        this.trailingAction = trailingActionFactory(trailingActionEl);
      }
      var rippleAdapter = __assign(__assign({}, MDCRipple.createAdapter(this)), { computeBoundingRect: function() {
        return _this.foundation.getDimensions();
      } });
      this.rippleSurface = rippleFactory(this.root, new MDCRippleFoundation(rippleAdapter));
    };
    MDCChip3.prototype.initialSyncWithDOM = function() {
      var _this = this;
      this.handleTrailingActionInteraction = function() {
        _this.foundation.handleTrailingActionInteraction();
      };
      this.handleTrailingActionNavigation = function(evt) {
        _this.foundation.handleTrailingActionNavigation(evt);
      };
      this.handleClick = function() {
        _this.foundation.handleClick();
      };
      this.handleKeydown = function(evt) {
        _this.foundation.handleKeydown(evt);
      };
      this.handleTransitionEnd = function(evt) {
        _this.foundation.handleTransitionEnd(evt);
      };
      this.handleFocusIn = function(evt) {
        _this.foundation.handleFocusIn(evt);
      };
      this.handleFocusOut = function(evt) {
        _this.foundation.handleFocusOut(evt);
      };
      this.listen("transitionend", this.handleTransitionEnd);
      this.listen("click", this.handleClick);
      this.listen("keydown", this.handleKeydown);
      this.listen("focusin", this.handleFocusIn);
      this.listen("focusout", this.handleFocusOut);
      if (this.trailingAction) {
        this.listen(strings.INTERACTION_EVENT, this.handleTrailingActionInteraction);
        this.listen(strings.NAVIGATION_EVENT, this.handleTrailingActionNavigation);
      }
    };
    MDCChip3.prototype.destroy = function() {
      this.rippleSurface.destroy();
      this.unlisten("transitionend", this.handleTransitionEnd);
      this.unlisten("keydown", this.handleKeydown);
      this.unlisten("click", this.handleClick);
      this.unlisten("focusin", this.handleFocusIn);
      this.unlisten("focusout", this.handleFocusOut);
      if (this.trailingAction) {
        this.unlisten(strings.INTERACTION_EVENT, this.handleTrailingActionInteraction);
        this.unlisten(strings.NAVIGATION_EVENT, this.handleTrailingActionNavigation);
      }
      _super.prototype.destroy.call(this);
    };
    MDCChip3.prototype.beginExit = function() {
      this.foundation.beginExit();
    };
    MDCChip3.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        addClass: function(className) {
          return _this.root.classList.add(className);
        },
        addClassToLeadingIcon: function(className) {
          if (_this.leadingIcon) {
            _this.leadingIcon.classList.add(className);
          }
        },
        eventTargetHasClass: function(target, className) {
          return target ? target.classList.contains(className) : false;
        },
        focusPrimaryAction: function() {
          if (_this.primaryAction) {
            _this.primaryAction.focus();
          }
        },
        focusTrailingAction: function() {
          if (_this.trailingAction) {
            _this.trailingAction.focus();
          }
        },
        getAttribute: function(attr) {
          return _this.root.getAttribute(attr);
        },
        getCheckmarkBoundingClientRect: function() {
          return _this.checkmark ? _this.checkmark.getBoundingClientRect() : null;
        },
        getComputedStyleValue: function(propertyName) {
          return window.getComputedStyle(_this.root).getPropertyValue(propertyName);
        },
        getRootBoundingClientRect: function() {
          return _this.root.getBoundingClientRect();
        },
        hasClass: function(className) {
          return _this.root.classList.contains(className);
        },
        hasLeadingIcon: function() {
          return !!_this.leadingIcon;
        },
        isRTL: function() {
          return window.getComputedStyle(_this.root).getPropertyValue("direction") === "rtl";
        },
        isTrailingActionNavigable: function() {
          if (_this.trailingAction) {
            return _this.trailingAction.isNavigable();
          }
          return false;
        },
        notifyInteraction: function() {
          return _this.emit(
            strings2.INTERACTION_EVENT,
            { chipId: _this.id },
            true
            /* shouldBubble */
          );
        },
        notifyNavigation: function(key, source) {
          return _this.emit(
            strings2.NAVIGATION_EVENT,
            { chipId: _this.id, key, source },
            true
            /* shouldBubble */
          );
        },
        notifyRemoval: function(removedAnnouncement) {
          _this.emit(
            strings2.REMOVAL_EVENT,
            { chipId: _this.id, removedAnnouncement },
            true
            /* shouldBubble */
          );
        },
        notifySelection: function(selected, shouldIgnore) {
          return _this.emit(
            strings2.SELECTION_EVENT,
            { chipId: _this.id, selected, shouldIgnore },
            true
            /* shouldBubble */
          );
        },
        notifyTrailingIconInteraction: function() {
          return _this.emit(
            strings2.TRAILING_ICON_INTERACTION_EVENT,
            { chipId: _this.id },
            true
            /* shouldBubble */
          );
        },
        notifyEditStart: function() {
        },
        notifyEditFinish: function() {
        },
        removeClass: function(className) {
          return _this.root.classList.remove(className);
        },
        removeClassFromLeadingIcon: function(className) {
          if (_this.leadingIcon) {
            _this.leadingIcon.classList.remove(className);
          }
        },
        removeTrailingActionFocus: function() {
          if (_this.trailingAction) {
            _this.trailingAction.removeFocus();
          }
        },
        setPrimaryActionAttr: function(attr, value) {
          if (_this.primaryAction) {
            _this.primaryAction.setAttribute(attr, value);
          }
        },
        setStyleProperty: function(propertyName, value) {
          return _this.root.style.setProperty(propertyName, value);
        }
      };
      return new MDCChipFoundation2(adapter);
    };
    MDCChip3.prototype.setSelectedFromChipSet = function(selected, shouldNotifyClients) {
      this.foundation.setSelectedFromChipSet(selected, shouldNotifyClients);
    };
    MDCChip3.prototype.focusPrimaryAction = function() {
      this.foundation.focusPrimaryAction();
    };
    MDCChip3.prototype.focusTrailingAction = function() {
      this.foundation.focusTrailingAction();
    };
    MDCChip3.prototype.removeFocus = function() {
      this.foundation.removeFocus();
    };
    MDCChip3.prototype.remove = function() {
      var parent = this.root.parentNode;
      if (parent !== null) {
        parent.removeChild(this.root);
      }
    };
    return MDCChip3;
  }(MDCComponent)
);

// node_modules/@material/chips/deprecated/chip-set/constants.js
var strings3 = {
  CHIP_SELECTOR: ".mdc-chip"
};
var cssClasses2 = {
  CHOICE: "mdc-chip-set--choice",
  FILTER: "mdc-chip-set--filter"
};

// node_modules/@material/chips/deprecated/chip-set/foundation.js
var MDCChipSetFoundation2 = (
  /** @class */
  function(_super) {
    __extends(MDCChipSetFoundation3, _super);
    function MDCChipSetFoundation3(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCChipSetFoundation3.defaultAdapter), adapter)) || this;
      _this.selectedChipIds = [];
      return _this;
    }
    Object.defineProperty(MDCChipSetFoundation3, "strings", {
      get: function() {
        return strings3;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCChipSetFoundation3, "cssClasses", {
      get: function() {
        return cssClasses2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCChipSetFoundation3, "defaultAdapter", {
      get: function() {
        return {
          announceMessage: function() {
            return void 0;
          },
          focusChipPrimaryActionAtIndex: function() {
            return void 0;
          },
          focusChipTrailingActionAtIndex: function() {
            return void 0;
          },
          getChipListCount: function() {
            return -1;
          },
          getIndexOfChipById: function() {
            return -1;
          },
          hasClass: function() {
            return false;
          },
          isRTL: function() {
            return false;
          },
          removeChipAtIndex: function() {
            return void 0;
          },
          removeFocusFromChipAtIndex: function() {
            return void 0;
          },
          selectChipAtIndex: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCChipSetFoundation3.prototype.getSelectedChipIds = function() {
      return this.selectedChipIds.slice();
    };
    MDCChipSetFoundation3.prototype.select = function(chipId) {
      this.selectImpl(chipId, false);
    };
    MDCChipSetFoundation3.prototype.handleChipInteraction = function(_a2) {
      var chipId = _a2.chipId;
      var index = this.adapter.getIndexOfChipById(chipId);
      this.removeFocusFromChipsExcept(index);
      if (this.adapter.hasClass(cssClasses2.CHOICE) || this.adapter.hasClass(cssClasses2.FILTER)) {
        this.toggleSelect(chipId);
      }
    };
    MDCChipSetFoundation3.prototype.handleChipSelection = function(_a2) {
      var chipId = _a2.chipId, selected = _a2.selected, shouldIgnore = _a2.shouldIgnore;
      if (shouldIgnore) {
        return;
      }
      var chipIsSelected = this.selectedChipIds.indexOf(chipId) >= 0;
      if (selected && !chipIsSelected) {
        this.select(chipId);
      } else if (!selected && chipIsSelected) {
        this.deselectImpl(chipId);
      }
    };
    MDCChipSetFoundation3.prototype.handleChipRemoval = function(_a2) {
      var chipId = _a2.chipId, removedAnnouncement = _a2.removedAnnouncement;
      if (removedAnnouncement) {
        this.adapter.announceMessage(removedAnnouncement);
      }
      var index = this.adapter.getIndexOfChipById(chipId);
      this.deselectAndNotifyClients(chipId);
      this.adapter.removeChipAtIndex(index);
      var maxIndex = this.adapter.getChipListCount() - 1;
      if (maxIndex < 0) {
        return;
      }
      var nextIndex = Math.min(index, maxIndex);
      this.removeFocusFromChipsExcept(nextIndex);
      this.adapter.focusChipTrailingActionAtIndex(nextIndex);
    };
    MDCChipSetFoundation3.prototype.handleChipNavigation = function(_a2) {
      var chipId = _a2.chipId, key = _a2.key, source = _a2.source;
      var maxIndex = this.adapter.getChipListCount() - 1;
      var index = this.adapter.getIndexOfChipById(chipId);
      if (index === -1 || !navigationKeys.has(key)) {
        return;
      }
      var isRTL = this.adapter.isRTL();
      var isLeftKey = key === strings2.ARROW_LEFT_KEY || key === strings2.IE_ARROW_LEFT_KEY;
      var isRightKey = key === strings2.ARROW_RIGHT_KEY || key === strings2.IE_ARROW_RIGHT_KEY;
      var isDownKey = key === strings2.ARROW_DOWN_KEY || key === strings2.IE_ARROW_DOWN_KEY;
      var shouldIncrement = !isRTL && isRightKey || isRTL && isLeftKey || isDownKey;
      var isHome = key === strings2.HOME_KEY;
      var isEnd = key === strings2.END_KEY;
      if (shouldIncrement) {
        index++;
      } else if (isHome) {
        index = 0;
      } else if (isEnd) {
        index = maxIndex;
      } else {
        index--;
      }
      if (index < 0 || index > maxIndex) {
        return;
      }
      this.removeFocusFromChipsExcept(index);
      this.focusChipAction(index, key, source);
    };
    MDCChipSetFoundation3.prototype.focusChipAction = function(index, key, source) {
      var shouldJumpChips = jumpChipKeys.has(key);
      if (shouldJumpChips && source === EventSource.PRIMARY) {
        return this.adapter.focusChipPrimaryActionAtIndex(index);
      }
      if (shouldJumpChips && source === EventSource.TRAILING) {
        return this.adapter.focusChipTrailingActionAtIndex(index);
      }
      var dir = this.getDirection(key);
      if (dir === Direction2.LEFT) {
        return this.adapter.focusChipTrailingActionAtIndex(index);
      }
      if (dir === Direction2.RIGHT) {
        return this.adapter.focusChipPrimaryActionAtIndex(index);
      }
    };
    MDCChipSetFoundation3.prototype.getDirection = function(key) {
      var isRTL = this.adapter.isRTL();
      var isLeftKey = key === strings2.ARROW_LEFT_KEY || key === strings2.IE_ARROW_LEFT_KEY;
      var isRightKey = key === strings2.ARROW_RIGHT_KEY || key === strings2.IE_ARROW_RIGHT_KEY;
      if (!isRTL && isLeftKey || isRTL && isRightKey) {
        return Direction2.LEFT;
      }
      return Direction2.RIGHT;
    };
    MDCChipSetFoundation3.prototype.deselectImpl = function(chipId, shouldNotifyClients) {
      if (shouldNotifyClients === void 0) {
        shouldNotifyClients = false;
      }
      var index = this.selectedChipIds.indexOf(chipId);
      if (index >= 0) {
        this.selectedChipIds.splice(index, 1);
        var chipIndex = this.adapter.getIndexOfChipById(chipId);
        this.adapter.selectChipAtIndex(
          chipIndex,
          /** isSelected */
          false,
          shouldNotifyClients
        );
      }
    };
    MDCChipSetFoundation3.prototype.deselectAndNotifyClients = function(chipId) {
      this.deselectImpl(chipId, true);
    };
    MDCChipSetFoundation3.prototype.toggleSelect = function(chipId) {
      if (this.selectedChipIds.indexOf(chipId) >= 0) {
        this.deselectAndNotifyClients(chipId);
      } else {
        this.selectAndNotifyClients(chipId);
      }
    };
    MDCChipSetFoundation3.prototype.removeFocusFromChipsExcept = function(index) {
      var chipCount = this.adapter.getChipListCount();
      for (var i = 0; i < chipCount; i++) {
        if (i !== index) {
          this.adapter.removeFocusFromChipAtIndex(i);
        }
      }
    };
    MDCChipSetFoundation3.prototype.selectAndNotifyClients = function(chipId) {
      this.selectImpl(chipId, true);
    };
    MDCChipSetFoundation3.prototype.selectImpl = function(chipId, shouldNotifyClients) {
      if (this.selectedChipIds.indexOf(chipId) >= 0) {
        return;
      }
      if (this.adapter.hasClass(cssClasses2.CHOICE) && this.selectedChipIds.length > 0) {
        var previouslySelectedChip = this.selectedChipIds[0];
        var previouslySelectedIndex = this.adapter.getIndexOfChipById(previouslySelectedChip);
        this.selectedChipIds = [];
        this.adapter.selectChipAtIndex(
          previouslySelectedIndex,
          /** isSelected */
          false,
          shouldNotifyClients
        );
      }
      this.selectedChipIds.push(chipId);
      var index = this.adapter.getIndexOfChipById(chipId);
      this.adapter.selectChipAtIndex(
        index,
        /** isSelected */
        true,
        shouldNotifyClients
      );
    };
    return MDCChipSetFoundation3;
  }(MDCFoundation)
);

// node_modules/@material/chips/deprecated/chip-set/component.js
var _a = MDCChipFoundation2.strings;
var INTERACTION_EVENT = _a.INTERACTION_EVENT;
var SELECTION_EVENT = _a.SELECTION_EVENT;
var REMOVAL_EVENT = _a.REMOVAL_EVENT;
var NAVIGATION_EVENT = _a.NAVIGATION_EVENT;
var CHIP_SELECTOR = MDCChipSetFoundation2.strings.CHIP_SELECTOR;
var idCounter = 0;
var MDCChipSet2 = (
  /** @class */
  function(_super) {
    __extends(MDCChipSet3, _super);
    function MDCChipSet3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCChipSet3.attachTo = function(root) {
      return new MDCChipSet3(root);
    };
    Object.defineProperty(MDCChipSet3.prototype, "chips", {
      get: function() {
        return this.chipsList.slice();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCChipSet3.prototype, "selectedChipIds", {
      /**
       * @return An array of the IDs of all selected chips.
       */
      get: function() {
        return this.foundation.getSelectedChipIds();
      },
      enumerable: false,
      configurable: true
    });
    MDCChipSet3.prototype.initialize = function(chipFactory) {
      if (chipFactory === void 0) {
        chipFactory = function(el) {
          return new MDCChip2(el);
        };
      }
      this.chipFactory = chipFactory;
      this.chipsList = this.instantiateChips(this.chipFactory);
    };
    MDCChipSet3.prototype.initialSyncWithDOM = function() {
      var e_1, _a2;
      var _this = this;
      try {
        for (var _b = __values(this.chipsList), _c = _b.next(); !_c.done; _c = _b.next()) {
          var chip = _c.value;
          if (chip.id && chip.selected) {
            this.foundation.select(chip.id);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            _a2.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      this.handleChipInteraction = function(evt) {
        return _this.foundation.handleChipInteraction(evt.detail);
      };
      this.handleChipSelection = function(evt) {
        return _this.foundation.handleChipSelection(evt.detail);
      };
      this.handleChipRemoval = function(evt) {
        return _this.foundation.handleChipRemoval(evt.detail);
      };
      this.handleChipNavigation = function(evt) {
        return _this.foundation.handleChipNavigation(evt.detail);
      };
      this.listen(INTERACTION_EVENT, this.handleChipInteraction);
      this.listen(SELECTION_EVENT, this.handleChipSelection);
      this.listen(REMOVAL_EVENT, this.handleChipRemoval);
      this.listen(NAVIGATION_EVENT, this.handleChipNavigation);
    };
    MDCChipSet3.prototype.destroy = function() {
      var e_2, _a2;
      try {
        for (var _b = __values(this.chipsList), _c = _b.next(); !_c.done; _c = _b.next()) {
          var chip = _c.value;
          chip.destroy();
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            _a2.call(_b);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      this.unlisten(INTERACTION_EVENT, this.handleChipInteraction);
      this.unlisten(SELECTION_EVENT, this.handleChipSelection);
      this.unlisten(REMOVAL_EVENT, this.handleChipRemoval);
      this.unlisten(NAVIGATION_EVENT, this.handleChipNavigation);
      _super.prototype.destroy.call(this);
    };
    MDCChipSet3.prototype.addChip = function(chipEl) {
      chipEl.id = chipEl.id || "mdc-chip-" + ++idCounter;
      this.chipsList.push(this.chipFactory(chipEl));
    };
    MDCChipSet3.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        announceMessage: function(message) {
          announce2(message);
        },
        focusChipPrimaryActionAtIndex: function(index) {
          _this.chipsList[index].focusPrimaryAction();
        },
        focusChipTrailingActionAtIndex: function(index) {
          _this.chipsList[index].focusTrailingAction();
        },
        getChipListCount: function() {
          return _this.chips.length;
        },
        getIndexOfChipById: function(chipId) {
          return _this.findChipIndex(chipId);
        },
        hasClass: function(className) {
          return _this.root.classList.contains(className);
        },
        isRTL: function() {
          return window.getComputedStyle(_this.root).getPropertyValue("direction") === "rtl";
        },
        removeChipAtIndex: function(index) {
          if (index >= 0 && index < _this.chips.length) {
            _this.chipsList[index].destroy();
            _this.chipsList[index].remove();
            _this.chipsList.splice(index, 1);
          }
        },
        removeFocusFromChipAtIndex: function(index) {
          _this.chipsList[index].removeFocus();
        },
        selectChipAtIndex: function(index, selected, shouldNotifyClients) {
          if (index >= 0 && index < _this.chips.length) {
            _this.chipsList[index].setSelectedFromChipSet(selected, shouldNotifyClients);
          }
        }
      };
      return new MDCChipSetFoundation2(adapter);
    };
    MDCChipSet3.prototype.instantiateChips = function(chipFactory) {
      var chipElements = [].slice.call(this.root.querySelectorAll(CHIP_SELECTOR));
      return chipElements.map(function(el) {
        el.id = el.id || "mdc-chip-" + ++idCounter;
        return chipFactory(el);
      });
    };
    MDCChipSet3.prototype.findChipIndex = function(chipId) {
      for (var i = 0; i < this.chips.length; i++) {
        if (this.chipsList[i].id === chipId) {
          return i;
        }
      }
      return -1;
    };
    return MDCChipSet3;
  }(MDCComponent)
);

// node_modules/@smui/ripple/dist/Ripple.js
var { applyPassive } = events_exports;
var { matches } = ponyfill_exports;
function Ripple(node, { ripple = true, surface = false, unbounded = false, disabled = false, color, active, rippleElement, eventTarget, activeTarget, addClass = (className) => node.classList.add(className), removeClass = (className) => node.classList.remove(className), addStyle = (name, value) => node.style.setProperty(name, value), initPromise = Promise.resolve() } = {}) {
  let instance5;
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let oldActive = active;
  let oldEventTarget = eventTarget;
  let oldActiveTarget = activeTarget;
  function handleProps() {
    if (surface) {
      addClass("mdc-ripple-surface");
      if (color === "primary") {
        addClass("smui-ripple-surface--primary");
        removeClass("smui-ripple-surface--secondary");
      } else if (color === "secondary") {
        removeClass("smui-ripple-surface--primary");
        addClass("smui-ripple-surface--secondary");
      } else {
        removeClass("smui-ripple-surface--primary");
        removeClass("smui-ripple-surface--secondary");
      }
    } else {
      removeClass("mdc-ripple-surface");
      removeClass("smui-ripple-surface--primary");
      removeClass("smui-ripple-surface--secondary");
    }
    if (instance5 && oldActive !== active) {
      oldActive = active;
      if (active) {
        instance5.activate();
      } else if (active === false) {
        instance5.deactivate();
      }
    }
    if (ripple && !instance5) {
      instance5 = new MDCRippleFoundation({
        addClass,
        browserSupportsCssVars: () => util_exports.supportsCssVariables(window),
        computeBoundingRect: () => (rippleElement || node).getBoundingClientRect(),
        containsEventTarget: (target) => node.contains(target),
        deregisterDocumentInteractionHandler: (evtType, handler) => document.documentElement.removeEventListener(evtType, handler, applyPassive()),
        deregisterInteractionHandler: (evtType, handler) => (eventTarget || node).removeEventListener(evtType, handler, applyPassive()),
        deregisterResizeHandler: (handler) => window.removeEventListener("resize", handler),
        getWindowPageOffset: () => ({
          x: window.pageXOffset,
          y: window.pageYOffset
        }),
        isSurfaceActive: () => active == null ? matches(activeTarget || node, ":active") : active,
        isSurfaceDisabled: () => !!disabled,
        isUnbounded: () => !!unbounded,
        registerDocumentInteractionHandler: (evtType, handler) => document.documentElement.addEventListener(evtType, handler, applyPassive()),
        registerInteractionHandler: (evtType, handler) => (eventTarget || node).addEventListener(evtType, handler, applyPassive()),
        registerResizeHandler: (handler) => window.addEventListener("resize", handler),
        removeClass,
        updateCssVariable: addStyle
      });
      initPromise.then(() => {
        if (instance5) {
          instance5.init();
          instance5.setUnbounded(unbounded);
        }
      });
    } else if (instance5 && !ripple) {
      initPromise.then(() => {
        if (instance5) {
          instance5.destroy();
          instance5 = void 0;
        }
      });
    }
    if (instance5 && (oldEventTarget !== eventTarget || oldActiveTarget !== activeTarget)) {
      oldEventTarget = eventTarget;
      oldActiveTarget = activeTarget;
      instance5.destroy();
      requestAnimationFrame(() => {
        if (instance5) {
          instance5.init();
          instance5.setUnbounded(unbounded);
        }
      });
    }
    if (!ripple && unbounded) {
      addClass("mdc-ripple-upgraded--unbounded");
    }
  }
  handleProps();
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  function layout() {
    if (instance5) {
      instance5.layout();
    }
  }
  return {
    update(props) {
      ({
        ripple,
        surface,
        unbounded,
        disabled,
        color,
        active,
        rippleElement,
        eventTarget,
        activeTarget,
        addClass,
        removeClass,
        addStyle,
        initPromise
      } = Object.assign({ ripple: true, surface: false, unbounded: false, disabled: false, color: void 0, active: void 0, rippleElement: void 0, eventTarget: void 0, activeTarget: void 0, addClass: (className) => node.classList.add(className), removeClass: (className) => node.classList.remove(className), addStyle: (name, value) => node.style.setProperty(name, value), initPromise: Promise.resolve() }, props));
      handleProps();
    },
    destroy() {
      if (instance5) {
        instance5.destroy();
        instance5 = void 0;
        removeClass("mdc-ripple-surface");
        removeClass("smui-ripple-surface--primary");
        removeClass("smui-ripple-surface--secondary");
      }
      if (removeLayoutListener) {
        removeLayoutListener();
      }
    }
  };
}

// node_modules/@smui/ripple/dist/index.js
var dist_default = Ripple;

// node_modules/@smui/chips/dist/Chip.svelte
var { Error: Error_1 } = globals;
var file = "node_modules/@smui/chips/dist/Chip.svelte";
function create_if_block_1(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "mdc-chip__ripple");
      add_location(div, file, 48, 4, 1531);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(48:2) {#if ripple && !$nonInteractive}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "mdc-chip__touch");
      add_location(div, file, 52, 4, 1601);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(52:2) {#if touch}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*ripple*/
    ctx[3] && !/*$nonInteractive*/
    ctx[14] && create_if_block_1(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[34].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[38],
    null
  );
  let if_block1 = (
    /*touch*/
    ctx[4] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_dev(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*ripple*/
        ctx2[3] && !/*$nonInteractive*/
        ctx2[14]
      ) {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[38],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[38]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[38],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*touch*/
        ctx2[4]
      ) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(1:0) <svelte:component   this={component}   {tag}   bind:this={element}   use={[     [       Ripple,       {         ripple: ripple && !$nonInteractive,         unbounded: false,         addClass,         removeClass,         addStyle,       },     ],     forwardEvents,     ...use,   ]}   class={classMap({     [className]: true,     'mdc-chip': true,     'mdc-chip--selected': selected,     'mdc-chip--touch': touch,     ...internalClasses,   })}   style={Object.entries(internalStyles)     .map(([name, value]) => `${name}: ${value};`)     .concat([style])     .join(' ')}   role=\\\"row\\\"   on:transitionend={instance && instance.handleTransitionEnd.bind(instance)}   on:click={instance && instance.handleClick.bind(instance)}   on:keydown={instance && instance.handleKeydown.bind(instance)}   on:focusin={instance && instance.handleFocusIn.bind(instance)}   on:focusout={instance && instance.handleFocusOut.bind(instance)}   on:SMUIChipTrailingAction:interaction={instance &&     instance.handleTrailingActionInteraction.bind(instance)}   on:SMUIChipTrailingAction:navigation={instance &&     instance.handleTrailingActionNavigation.bind(instance)}   on:SMUIChipsChipPrimaryAction:mount={handleSMUIChipsChipPrimaryAction}   on:SMUIChipsChipPrimaryAction:unmount={() =>     (primaryActionAccessor = undefined)}   on:SMUIChipsChipTrailingAction:mount={handleSMUIChipsChipTrailingAction}   on:SMUIChipsChipTrailingAction:unmount={() =>     (trailingActionAccessor = undefined)}   {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    { tag: (
      /*tag*/
      ctx[6]
    ) },
    {
      use: [
        [
          dist_default,
          {
            ripple: (
              /*ripple*/
              ctx[3] && !/*$nonInteractive*/
              ctx[14]
            ),
            unbounded: false,
            addClass: (
              /*addClass*/
              ctx[25]
            ),
            removeClass: (
              /*removeClass*/
              ctx[26]
            ),
            addStyle: (
              /*addStyle*/
              ctx[27]
            )
          }
        ],
        /*forwardEvents*/
        ctx[15],
        .../*use*/
        ctx[0]
      ]
    },
    {
      class: classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-chip": true,
        "mdc-chip--selected": (
          /*selected*/
          ctx[8]
        ),
        "mdc-chip--touch": (
          /*touch*/
          ctx[4]
        ),
        .../*internalClasses*/
        ctx[10]
      })
    },
    {
      style: Object.entries(
        /*internalStyles*/
        ctx[11]
      ).map(func).concat([
        /*style*/
        ctx[2]
      ]).join(" ")
    },
    { role: "row" },
    /*$$restProps*/
    ctx[28]
  ];
  var switch_value = (
    /*component*/
    ctx[5]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: ctx2 }
    };
    if (dirty !== void 0 && dirty[0] & /*tag, ripple, $nonInteractive, addClass, removeClass, addStyle, forwardEvents, use, className, selected, touch, internalClasses, internalStyles, style, $$restProps*/
    503369055) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [
        dirty[0] & /*tag*/
        64 && { tag: (
          /*tag*/
          ctx2[6]
        ) },
        dirty[0] & /*ripple, $nonInteractive, addClass, removeClass, addStyle, forwardEvents, use*/
        234930185 && {
          use: [
            [
              dist_default,
              {
                ripple: (
                  /*ripple*/
                  ctx2[3] && !/*$nonInteractive*/
                  ctx2[14]
                ),
                unbounded: false,
                addClass: (
                  /*addClass*/
                  ctx2[25]
                ),
                removeClass: (
                  /*removeClass*/
                  ctx2[26]
                ),
                addStyle: (
                  /*addStyle*/
                  ctx2[27]
                )
              }
            ],
            /*forwardEvents*/
            ctx2[15],
            .../*use*/
            ctx2[0]
          ]
        },
        dirty[0] & /*className, selected, touch, internalClasses*/
        1298 && {
          class: classMap({
            [
              /*className*/
              ctx2[1]
            ]: true,
            "mdc-chip": true,
            "mdc-chip--selected": (
              /*selected*/
              ctx2[8]
            ),
            "mdc-chip--touch": (
              /*touch*/
              ctx2[4]
            ),
            .../*internalClasses*/
            ctx2[10]
          })
        },
        dirty[0] & /*internalStyles, style*/
        2052 && {
          style: Object.entries(
            /*internalStyles*/
            ctx2[11]
          ).map(func).concat([
            /*style*/
            ctx2[2]
          ]).join(" ")
        },
        switch_instance_spread_levels[4],
        dirty[0] & /*$$restProps*/
        268435456 && get_spread_object(
          /*$$restProps*/
          ctx2[28]
        )
      ]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[35](switch_instance);
    switch_instance.$on("transitionend", function() {
      if (is_function(
        /*instance*/
        ctx[7] && /*instance*/
        ctx[7].handleTransitionEnd.bind(
          /*instance*/
          ctx[7]
        )
      ))
        /*instance*/
        (ctx[7] && /*instance*/
        ctx[7].handleTransitionEnd.bind(
          /*instance*/
          ctx[7]
        )).apply(this, arguments);
    });
    switch_instance.$on("click", function() {
      if (is_function(
        /*instance*/
        ctx[7] && /*instance*/
        ctx[7].handleClick.bind(
          /*instance*/
          ctx[7]
        )
      ))
        /*instance*/
        (ctx[7] && /*instance*/
        ctx[7].handleClick.bind(
          /*instance*/
          ctx[7]
        )).apply(this, arguments);
    });
    switch_instance.$on("keydown", function() {
      if (is_function(
        /*instance*/
        ctx[7] && /*instance*/
        ctx[7].handleKeydown.bind(
          /*instance*/
          ctx[7]
        )
      ))
        /*instance*/
        (ctx[7] && /*instance*/
        ctx[7].handleKeydown.bind(
          /*instance*/
          ctx[7]
        )).apply(this, arguments);
    });
    switch_instance.$on("focusin", function() {
      if (is_function(
        /*instance*/
        ctx[7] && /*instance*/
        ctx[7].handleFocusIn.bind(
          /*instance*/
          ctx[7]
        )
      ))
        /*instance*/
        (ctx[7] && /*instance*/
        ctx[7].handleFocusIn.bind(
          /*instance*/
          ctx[7]
        )).apply(this, arguments);
    });
    switch_instance.$on("focusout", function() {
      if (is_function(
        /*instance*/
        ctx[7] && /*instance*/
        ctx[7].handleFocusOut.bind(
          /*instance*/
          ctx[7]
        )
      ))
        /*instance*/
        (ctx[7] && /*instance*/
        ctx[7].handleFocusOut.bind(
          /*instance*/
          ctx[7]
        )).apply(this, arguments);
    });
    switch_instance.$on("SMUIChipTrailingAction:interaction", function() {
      if (is_function(
        /*instance*/
        ctx[7] && /*instance*/
        ctx[7].handleTrailingActionInteraction.bind(
          /*instance*/
          ctx[7]
        )
      ))
        /*instance*/
        (ctx[7] && /*instance*/
        ctx[7].handleTrailingActionInteraction.bind(
          /*instance*/
          ctx[7]
        )).apply(this, arguments);
    });
    switch_instance.$on("SMUIChipTrailingAction:navigation", function() {
      if (is_function(
        /*instance*/
        ctx[7] && /*instance*/
        ctx[7].handleTrailingActionNavigation.bind(
          /*instance*/
          ctx[7]
        )
      ))
        /*instance*/
        (ctx[7] && /*instance*/
        ctx[7].handleTrailingActionNavigation.bind(
          /*instance*/
          ctx[7]
        )).apply(this, arguments);
    });
    switch_instance.$on(
      "SMUIChipsChipPrimaryAction:mount",
      /*handleSMUIChipsChipPrimaryAction*/
      ctx[23]
    );
    switch_instance.$on(
      "SMUIChipsChipPrimaryAction:unmount",
      /*SMUIChipsChipPrimaryAction_unmount_handler*/
      ctx[36]
    );
    switch_instance.$on(
      "SMUIChipsChipTrailingAction:mount",
      /*handleSMUIChipsChipTrailingAction*/
      ctx[24]
    );
    switch_instance.$on(
      "SMUIChipsChipTrailingAction:unmount",
      /*SMUIChipsChipTrailingAction_unmount_handler*/
      ctx[37]
    );
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*component*/
      32 && switch_value !== (switch_value = /*component*/
      ctx[5])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx, dirty));
          ctx[35](switch_instance);
          switch_instance.$on("transitionend", function() {
            if (is_function(
              /*instance*/
              ctx[7] && /*instance*/
              ctx[7].handleTransitionEnd.bind(
                /*instance*/
                ctx[7]
              )
            ))
              /*instance*/
              (ctx[7] && /*instance*/
              ctx[7].handleTransitionEnd.bind(
                /*instance*/
                ctx[7]
              )).apply(this, arguments);
          });
          switch_instance.$on("click", function() {
            if (is_function(
              /*instance*/
              ctx[7] && /*instance*/
              ctx[7].handleClick.bind(
                /*instance*/
                ctx[7]
              )
            ))
              /*instance*/
              (ctx[7] && /*instance*/
              ctx[7].handleClick.bind(
                /*instance*/
                ctx[7]
              )).apply(this, arguments);
          });
          switch_instance.$on("keydown", function() {
            if (is_function(
              /*instance*/
              ctx[7] && /*instance*/
              ctx[7].handleKeydown.bind(
                /*instance*/
                ctx[7]
              )
            ))
              /*instance*/
              (ctx[7] && /*instance*/
              ctx[7].handleKeydown.bind(
                /*instance*/
                ctx[7]
              )).apply(this, arguments);
          });
          switch_instance.$on("focusin", function() {
            if (is_function(
              /*instance*/
              ctx[7] && /*instance*/
              ctx[7].handleFocusIn.bind(
                /*instance*/
                ctx[7]
              )
            ))
              /*instance*/
              (ctx[7] && /*instance*/
              ctx[7].handleFocusIn.bind(
                /*instance*/
                ctx[7]
              )).apply(this, arguments);
          });
          switch_instance.$on("focusout", function() {
            if (is_function(
              /*instance*/
              ctx[7] && /*instance*/
              ctx[7].handleFocusOut.bind(
                /*instance*/
                ctx[7]
              )
            ))
              /*instance*/
              (ctx[7] && /*instance*/
              ctx[7].handleFocusOut.bind(
                /*instance*/
                ctx[7]
              )).apply(this, arguments);
          });
          switch_instance.$on("SMUIChipTrailingAction:interaction", function() {
            if (is_function(
              /*instance*/
              ctx[7] && /*instance*/
              ctx[7].handleTrailingActionInteraction.bind(
                /*instance*/
                ctx[7]
              )
            ))
              /*instance*/
              (ctx[7] && /*instance*/
              ctx[7].handleTrailingActionInteraction.bind(
                /*instance*/
                ctx[7]
              )).apply(this, arguments);
          });
          switch_instance.$on("SMUIChipTrailingAction:navigation", function() {
            if (is_function(
              /*instance*/
              ctx[7] && /*instance*/
              ctx[7].handleTrailingActionNavigation.bind(
                /*instance*/
                ctx[7]
              )
            ))
              /*instance*/
              (ctx[7] && /*instance*/
              ctx[7].handleTrailingActionNavigation.bind(
                /*instance*/
                ctx[7]
              )).apply(this, arguments);
          });
          switch_instance.$on(
            "SMUIChipsChipPrimaryAction:mount",
            /*handleSMUIChipsChipPrimaryAction*/
            ctx[23]
          );
          switch_instance.$on(
            "SMUIChipsChipPrimaryAction:unmount",
            /*SMUIChipsChipPrimaryAction_unmount_handler*/
            ctx[36]
          );
          switch_instance.$on(
            "SMUIChipsChipTrailingAction:mount",
            /*handleSMUIChipsChipTrailingAction*/
            ctx[24]
          );
          switch_instance.$on(
            "SMUIChipsChipTrailingAction:unmount",
            /*SMUIChipsChipTrailingAction_unmount_handler*/
            ctx[37]
          );
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*tag, ripple, $nonInteractive, addClass, removeClass, addStyle, forwardEvents, use, className, selected, touch, internalClasses, internalStyles, style, $$restProps*/
        503369055 ? get_spread_update(switch_instance_spread_levels, [
          dirty[0] & /*tag*/
          64 && { tag: (
            /*tag*/
            ctx[6]
          ) },
          dirty[0] & /*ripple, $nonInteractive, addClass, removeClass, addStyle, forwardEvents, use*/
          234930185 && {
            use: [
              [
                dist_default,
                {
                  ripple: (
                    /*ripple*/
                    ctx[3] && !/*$nonInteractive*/
                    ctx[14]
                  ),
                  unbounded: false,
                  addClass: (
                    /*addClass*/
                    ctx[25]
                  ),
                  removeClass: (
                    /*removeClass*/
                    ctx[26]
                  ),
                  addStyle: (
                    /*addStyle*/
                    ctx[27]
                  )
                }
              ],
              /*forwardEvents*/
              ctx[15],
              .../*use*/
              ctx[0]
            ]
          },
          dirty[0] & /*className, selected, touch, internalClasses*/
          1298 && {
            class: classMap({
              [
                /*className*/
                ctx[1]
              ]: true,
              "mdc-chip": true,
              "mdc-chip--selected": (
                /*selected*/
                ctx[8]
              ),
              "mdc-chip--touch": (
                /*touch*/
                ctx[4]
              ),
              .../*internalClasses*/
              ctx[10]
            })
          },
          dirty[0] & /*internalStyles, style*/
          2052 && {
            style: Object.entries(
              /*internalStyles*/
              ctx[11]
            ).map(func).concat([
              /*style*/
              ctx[2]
            ]).join(" ")
          },
          switch_instance_spread_levels[4],
          dirty[0] & /*$$restProps*/
          268435456 && get_spread_object(
            /*$$restProps*/
            ctx[28]
          )
        ]) : {};
        if (dirty[0] & /*touch, ripple, $nonInteractive*/
        16408 | dirty[1] & /*$$scope*/
        128) {
          switch_instance_changes.$$scope = { dirty, ctx };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      ctx[35](null);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func = ([name, value]) => `${name}: ${value};`;
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "chip",
    "ripple",
    "touch",
    "shouldRemoveOnTrailingIconClick",
    "shouldFocusPrimaryActionOnClick",
    "component",
    "tag",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $index;
  let $choice;
  let $leadingIconClassesStore;
  let $isSelectedStore;
  let $shouldRemoveOnTrailingIconClickStore;
  let $initialSelectedStore;
  let $nonInteractive;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Chip", slots, ["default"]);
  const { MDCChipFoundation: MDCChipFoundation3 } = deprecated_exports;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { chip: chipId } = $$props;
  let { ripple = true } = $$props;
  let { touch = false } = $$props;
  let { shouldRemoveOnTrailingIconClick = true } = $$props;
  let { shouldFocusPrimaryActionOnClick = true } = $$props;
  let element2;
  let instance5;
  let internalClasses = {};
  let leadingIconClasses = {};
  let internalStyles = {};
  const initialSelectedStore = getContext("SMUI:chips:chip:initialSelected");
  validate_store(initialSelectedStore, "initialSelectedStore");
  component_subscribe($$self, initialSelectedStore, (value) => $$invalidate(44, $initialSelectedStore = value));
  let selected = $initialSelectedStore;
  let primaryActionAccessor = void 0;
  let trailingActionAccessor = void 0;
  const nonInteractive = getContext("SMUI:chips:nonInteractive");
  validate_store(nonInteractive, "nonInteractive");
  component_subscribe($$self, nonInteractive, (value) => $$invalidate(14, $nonInteractive = value));
  const choice = getContext("SMUI:chips:choice");
  validate_store(choice, "choice");
  component_subscribe($$self, choice, (value) => $$invalidate(40, $choice = value));
  const index = getContext("SMUI:chips:chip:index");
  validate_store(index, "index");
  component_subscribe($$self, index, (value) => $$invalidate(39, $index = value));
  let { component = SmuiElement_default } = $$props;
  let { tag = component === SmuiElement_default ? "div" : void 0 } = $$props;
  const shouldRemoveOnTrailingIconClickStore = writable(shouldRemoveOnTrailingIconClick);
  validate_store(shouldRemoveOnTrailingIconClickStore, "shouldRemoveOnTrailingIconClickStore");
  component_subscribe($$self, shouldRemoveOnTrailingIconClickStore, (value) => $$invalidate(43, $shouldRemoveOnTrailingIconClickStore = value));
  setContext("SMUI:chips:chip:shouldRemoveOnTrailingIconClick", shouldRemoveOnTrailingIconClickStore);
  const isSelectedStore = writable(selected);
  validate_store(isSelectedStore, "isSelectedStore");
  component_subscribe($$self, isSelectedStore, (value) => $$invalidate(42, $isSelectedStore = value));
  setContext("SMUI:chips:chip:isSelected", isSelectedStore);
  const leadingIconClassesStore = writable(leadingIconClasses);
  validate_store(leadingIconClassesStore, "leadingIconClassesStore");
  component_subscribe($$self, leadingIconClassesStore, (value) => $$invalidate(41, $leadingIconClassesStore = value));
  setContext("SMUI:chips:chip:leadingIconClasses", leadingIconClassesStore);
  setContext("SMUI:chips:chip:focusable", $choice && selected || $index === 0);
  if (!chipId) {
    throw new Error("The chip property is required! It should be passed down from the Set to the Chip.");
  }
  onMount(() => {
    $$invalidate(7, instance5 = new MDCChipFoundation3({
      addClass,
      addClassToLeadingIcon: addLeadingIconClass,
      eventTargetHasClass: (target, className2) => target && "classList" in target ? target.classList.contains(className2) : false,
      focusPrimaryAction: () => {
        if (primaryActionAccessor) {
          primaryActionAccessor.focus();
        }
      },
      focusTrailingAction: () => {
        if (trailingActionAccessor) {
          trailingActionAccessor.focus();
        }
      },
      getAttribute: (attr) => getElement().getAttribute(attr),
      getCheckmarkBoundingClientRect: () => {
        const target = getElement().querySelector(".mdc-chip__checkmark");
        if (target) {
          return target.getBoundingClientRect();
        }
        return null;
      },
      getComputedStyleValue: getStyle,
      getRootBoundingClientRect: () => getElement().getBoundingClientRect(),
      hasClass,
      hasLeadingIcon: () => {
        const target = getElement().querySelector(".mdc-chip__icon--leading");
        return !!target;
      },
      isRTL: () => getComputedStyle(getElement()).getPropertyValue("direction") === "rtl",
      isTrailingActionNavigable: () => {
        if (trailingActionAccessor) {
          return trailingActionAccessor.isNavigable();
        }
        return false;
      },
      notifyInteraction: () => dispatch(getElement(), "SMUIChip:interaction", { chipId }, void 0, true),
      notifyNavigation: (key, source) => dispatch(getElement(), "SMUIChip:navigation", { chipId, key, source }, void 0, true),
      notifyRemoval: (removedAnnouncement) => {
        dispatch(getElement(), "SMUIChip:removal", { chipId, removedAnnouncement }, void 0, true);
      },
      notifySelection: (selected2, shouldIgnore) => dispatch(getElement(), "SMUIChip:selection", { chipId, selected: selected2, shouldIgnore }, void 0, true),
      notifyTrailingIconInteraction: () => dispatch(getElement(), "SMUIChip:trailingIconInteraction", { chipId }, void 0, true),
      notifyEditStart: () => {
      },
      /* Not Implemented. */
      notifyEditFinish: () => {
      },
      /* Not Implemented. */
      removeClass,
      removeClassFromLeadingIcon: removeLeadingIconClass,
      removeTrailingActionFocus: () => {
        if (trailingActionAccessor) {
          trailingActionAccessor.removeFocus();
        }
      },
      setPrimaryActionAttr: (attr, value) => {
        if (primaryActionAccessor) {
          primaryActionAccessor.addAttr(attr, value);
        }
      },
      setStyleProperty: addStyle
    }));
    const accessor = {
      chipId,
      get selected() {
        return selected;
      },
      focusPrimaryAction,
      focusTrailingAction,
      removeFocus,
      setSelectedFromChipSet
    };
    dispatch(getElement(), "SMUIChipsChip:mount", accessor);
    instance5.init();
    return () => {
      dispatch(getElement(), "SMUIChipsChip:unmount", accessor);
      instance5.destroy();
    };
  });
  function handleSMUIChipsChipPrimaryAction(event) {
    $$invalidate(12, primaryActionAccessor = event.detail);
  }
  function handleSMUIChipsChipTrailingAction(event) {
    $$invalidate(13, trailingActionAccessor = event.detail);
  }
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(10, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(10, internalClasses[className2] = false, internalClasses);
    }
  }
  function addLeadingIconClass(className2) {
    if (!leadingIconClasses[className2]) {
      $$invalidate(33, leadingIconClasses[className2] = true, leadingIconClasses);
    }
  }
  function removeLeadingIconClass(className2) {
    if (!(className2 in leadingIconClasses) || leadingIconClasses[className2]) {
      $$invalidate(33, leadingIconClasses[className2] = false, leadingIconClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(11, internalStyles);
      } else {
        $$invalidate(11, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function getStyle(name) {
    return name in internalStyles ? internalStyles[name] : getComputedStyle(getElement()).getPropertyValue(name);
  }
  function setSelectedFromChipSet(value, shouldNotifyClients) {
    $$invalidate(8, selected = value);
    instance5.setSelectedFromChipSet(selected, shouldNotifyClients);
  }
  function focusPrimaryAction() {
    instance5.focusPrimaryAction();
  }
  function focusTrailingAction() {
    instance5.focusTrailingAction();
  }
  function removeFocus() {
    instance5.removeFocus();
  }
  function getElement() {
    return element2.getElement();
  }
  $$self.$$.on_mount.push(function() {
    if (chipId === void 0 && !("chip" in $$props || $$self.$$.bound[$$self.$$.props["chip"]])) {
      console.warn("<Chip> was created without expected prop 'chip'");
    }
  });
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(9, element2);
    });
  }
  const SMUIChipsChipPrimaryAction_unmount_handler = () => $$invalidate(12, primaryActionAccessor = void 0);
  const SMUIChipsChipTrailingAction_unmount_handler = () => $$invalidate(13, trailingActionAccessor = void 0);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(28, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(2, style = $$new_props.style);
    if ("chip" in $$new_props)
      $$invalidate(29, chipId = $$new_props.chip);
    if ("ripple" in $$new_props)
      $$invalidate(3, ripple = $$new_props.ripple);
    if ("touch" in $$new_props)
      $$invalidate(4, touch = $$new_props.touch);
    if ("shouldRemoveOnTrailingIconClick" in $$new_props)
      $$invalidate(30, shouldRemoveOnTrailingIconClick = $$new_props.shouldRemoveOnTrailingIconClick);
    if ("shouldFocusPrimaryActionOnClick" in $$new_props)
      $$invalidate(31, shouldFocusPrimaryActionOnClick = $$new_props.shouldFocusPrimaryActionOnClick);
    if ("component" in $$new_props)
      $$invalidate(5, component = $$new_props.component);
    if ("tag" in $$new_props)
      $$invalidate(6, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(38, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    deprecated: deprecated_exports,
    onMount,
    setContext,
    getContext,
    writable,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    dispatch,
    Ripple: dist_default,
    SmuiElement: SmuiElement_default,
    MDCChipFoundation: MDCChipFoundation3,
    forwardEvents,
    use,
    className,
    style,
    chipId,
    ripple,
    touch,
    shouldRemoveOnTrailingIconClick,
    shouldFocusPrimaryActionOnClick,
    element: element2,
    instance: instance5,
    internalClasses,
    leadingIconClasses,
    internalStyles,
    initialSelectedStore,
    selected,
    primaryActionAccessor,
    trailingActionAccessor,
    nonInteractive,
    choice,
    index,
    component,
    tag,
    shouldRemoveOnTrailingIconClickStore,
    isSelectedStore,
    leadingIconClassesStore,
    handleSMUIChipsChipPrimaryAction,
    handleSMUIChipsChipTrailingAction,
    hasClass,
    addClass,
    removeClass,
    addLeadingIconClass,
    removeLeadingIconClass,
    addStyle,
    getStyle,
    setSelectedFromChipSet,
    focusPrimaryAction,
    focusTrailingAction,
    removeFocus,
    getElement,
    $index,
    $choice,
    $leadingIconClassesStore,
    $isSelectedStore,
    $shouldRemoveOnTrailingIconClickStore,
    $initialSelectedStore,
    $nonInteractive
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(2, style = $$new_props.style);
    if ("chipId" in $$props)
      $$invalidate(29, chipId = $$new_props.chipId);
    if ("ripple" in $$props)
      $$invalidate(3, ripple = $$new_props.ripple);
    if ("touch" in $$props)
      $$invalidate(4, touch = $$new_props.touch);
    if ("shouldRemoveOnTrailingIconClick" in $$props)
      $$invalidate(30, shouldRemoveOnTrailingIconClick = $$new_props.shouldRemoveOnTrailingIconClick);
    if ("shouldFocusPrimaryActionOnClick" in $$props)
      $$invalidate(31, shouldFocusPrimaryActionOnClick = $$new_props.shouldFocusPrimaryActionOnClick);
    if ("element" in $$props)
      $$invalidate(9, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(7, instance5 = $$new_props.instance);
    if ("internalClasses" in $$props)
      $$invalidate(10, internalClasses = $$new_props.internalClasses);
    if ("leadingIconClasses" in $$props)
      $$invalidate(33, leadingIconClasses = $$new_props.leadingIconClasses);
    if ("internalStyles" in $$props)
      $$invalidate(11, internalStyles = $$new_props.internalStyles);
    if ("selected" in $$props)
      $$invalidate(8, selected = $$new_props.selected);
    if ("primaryActionAccessor" in $$props)
      $$invalidate(12, primaryActionAccessor = $$new_props.primaryActionAccessor);
    if ("trailingActionAccessor" in $$props)
      $$invalidate(13, trailingActionAccessor = $$new_props.trailingActionAccessor);
    if ("component" in $$props)
      $$invalidate(5, component = $$new_props.component);
    if ("tag" in $$props)
      $$invalidate(6, tag = $$new_props.tag);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*shouldRemoveOnTrailingIconClick*/
    1073741824) {
      $:
        set_store_value(shouldRemoveOnTrailingIconClickStore, $shouldRemoveOnTrailingIconClickStore = shouldRemoveOnTrailingIconClick, $shouldRemoveOnTrailingIconClickStore);
    }
    if ($$self.$$.dirty[0] & /*selected*/
    256) {
      $:
        set_store_value(isSelectedStore, $isSelectedStore = selected, $isSelectedStore);
    }
    if ($$self.$$.dirty[1] & /*leadingIconClasses*/
    4) {
      $:
        set_store_value(leadingIconClassesStore, $leadingIconClassesStore = leadingIconClasses, $leadingIconClassesStore);
    }
    if ($$self.$$.dirty[0] & /*instance, shouldRemoveOnTrailingIconClick*/
    1073741952) {
      $:
        if (instance5 && instance5.getShouldRemoveOnTrailingIconClick() !== shouldRemoveOnTrailingIconClick) {
          instance5.setShouldRemoveOnTrailingIconClick(shouldRemoveOnTrailingIconClick);
        }
    }
    if ($$self.$$.dirty[0] & /*instance*/
    128 | $$self.$$.dirty[1] & /*shouldFocusPrimaryActionOnClick*/
    1) {
      $:
        if (instance5) {
          instance5.setShouldFocusPrimaryActionOnClick(shouldFocusPrimaryActionOnClick);
        }
    }
  };
  return [
    use,
    className,
    style,
    ripple,
    touch,
    component,
    tag,
    instance5,
    selected,
    element2,
    internalClasses,
    internalStyles,
    primaryActionAccessor,
    trailingActionAccessor,
    $nonInteractive,
    forwardEvents,
    initialSelectedStore,
    nonInteractive,
    choice,
    index,
    shouldRemoveOnTrailingIconClickStore,
    isSelectedStore,
    leadingIconClassesStore,
    handleSMUIChipsChipPrimaryAction,
    handleSMUIChipsChipTrailingAction,
    addClass,
    removeClass,
    addStyle,
    $$restProps,
    chipId,
    shouldRemoveOnTrailingIconClick,
    shouldFocusPrimaryActionOnClick,
    getElement,
    leadingIconClasses,
    slots,
    switch_instance_binding,
    SMUIChipsChipPrimaryAction_unmount_handler,
    SMUIChipsChipTrailingAction_unmount_handler,
    $$scope
  ];
}
var Chip = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_1,
      create_fragment,
      safe_not_equal,
      {
        use: 0,
        class: 1,
        style: 2,
        chip: 29,
        ripple: 3,
        touch: 4,
        shouldRemoveOnTrailingIconClick: 30,
        shouldFocusPrimaryActionOnClick: 31,
        component: 5,
        tag: 6,
        getElement: 32
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Chip",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error_1("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_1("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error_1("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error_1("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error_1("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error_1("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chip() {
    throw new Error_1("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chip(value) {
    throw new Error_1("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ripple() {
    throw new Error_1("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ripple(value) {
    throw new Error_1("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get touch() {
    throw new Error_1("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set touch(value) {
    throw new Error_1("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shouldRemoveOnTrailingIconClick() {
    throw new Error_1("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shouldRemoveOnTrailingIconClick(value) {
    throw new Error_1("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shouldFocusPrimaryActionOnClick() {
    throw new Error_1("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shouldFocusPrimaryActionOnClick(value) {
    throw new Error_1("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error_1("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error_1("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error_1("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error_1("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[32];
  }
  set getElement(value) {
    throw new Error_1("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Chip_default = Chip;

// node_modules/@smui/chips/dist/Set.svelte
var file2 = "node_modules/@smui/chips/dist/Set.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[37] = list[i];
  child_ctx[39] = i;
  return child_ctx;
}
var get_default_slot_changes = (dirty) => ({ chip: dirty[0] & /*chips*/
1 });
var get_default_slot_context = (ctx) => ({ chip: (
  /*chip*/
  ctx[37]
) });
function create_default_slot_1(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[25].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope, chips*/
        134217729)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[27]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[27],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: '(24:6) <ContextFragment         key=\\"SMUI:chips:chip:initialSelected\\"         value={initialSelected[i]}       >',
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let contextfragment;
  let t;
  let current;
  contextfragment = new ContextFragment_default({
    props: {
      key: "SMUI:chips:chip:initialSelected",
      value: (
        /*initialSelected*/
        ctx[10][
          /*i*/
          ctx[39]
        ]
      ),
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(contextfragment.$$.fragment);
      t = space();
    },
    m: function mount(target, anchor) {
      mount_component(contextfragment, target, anchor);
      insert_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const contextfragment_changes = {};
      if (dirty[0] & /*chips*/
      1)
        contextfragment_changes.value = /*initialSelected*/
        ctx2[10][
          /*i*/
          ctx2[39]
        ];
      if (dirty[0] & /*$$scope, chips*/
      134217729) {
        contextfragment_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contextfragment.$set(contextfragment_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(contextfragment.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(contextfragment.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(contextfragment, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: '(23:4) <ContextFragment key=\\"SMUI:chips:chip:index\\" value={i}>',
    ctx
  });
  return block;
}
function create_each_block(key_2, ctx) {
  let first;
  let contextfragment;
  let current;
  contextfragment = new ContextFragment_default({
    props: {
      key: "SMUI:chips:chip:index",
      value: (
        /*i*/
        ctx[39]
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    key: key_2,
    first: null,
    c: function create() {
      first = empty();
      create_component(contextfragment.$$.fragment);
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_dev(target, first, anchor);
      mount_component(contextfragment, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const contextfragment_changes = {};
      if (dirty[0] & /*chips*/
      1)
        contextfragment_changes.value = /*i*/
        ctx[39];
      if (dirty[0] & /*$$scope, chips*/
      134217729) {
        contextfragment_changes.$$scope = { dirty, ctx };
      }
      contextfragment.$set(contextfragment_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(contextfragment.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(contextfragment.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(contextfragment, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(22:2) {#each chips as chip, i (key(chip))}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like_dev(
    /*chips*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*key*/
    ctx2[3](
      /*chip*/
      ctx2[37]
    )
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  let div_levels = [
    {
      class: div_class_value = classMap({
        [
          /*className*/
          ctx[2]
        ]: true,
        "mdc-chip-set": true,
        "smui-chip-set--non-interactive": (
          /*nonInteractive*/
          ctx[4]
        ),
        "mdc-chip-set--choice": (
          /*choice*/
          ctx[5]
        ),
        "mdc-chip-set--filter": (
          /*filter*/
          ctx[6]
        ),
        "mdc-chip-set--input": (
          /*input*/
          ctx[7]
        )
      })
    },
    { role: "grid" },
    /*$$restProps*/
    ctx[20]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      set_attributes(div, div_data);
      add_location(div, file2, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      ctx[26](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div,
            /*use*/
            ctx[1]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[9].call(null, div)),
          listen_dev(
            div,
            "SMUIChipsChip:mount",
            /*handleChipMount*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "SMUIChipsChip:unmount",
            /*handleChipUnmount*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "SMUIChip:interaction",
            /*handleChipInteraction*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "SMUIChip:selection",
            /*handleChipSelection*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "SMUIChip:removal",
            /*handleChipRemoval*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "SMUIChip:navigation",
            /*handleChipNavigation*/
            ctx[19],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*chips, initialSelected, $$scope, key*/
      134218761) {
        each_value = ensure_array_like_dev(
          /*chips*/
          ctx2[0]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*className, nonInteractive, choice, filter, input*/
        244 && div_class_value !== (div_class_value = classMap({
          [
            /*className*/
            ctx2[2]
          ]: true,
          "mdc-chip-set": true,
          "smui-chip-set--non-interactive": (
            /*nonInteractive*/
            ctx2[4]
          ),
          "mdc-chip-set--choice": (
            /*choice*/
            ctx2[5]
          ),
          "mdc-chip-set--filter": (
            /*filter*/
            ctx2[6]
          ),
          "mdc-chip-set--input": (
            /*input*/
            ctx2[7]
          )
        }))) && { class: div_class_value },
        { role: "grid" },
        dirty[0] & /*$$restProps*/
        1048576 && /*$$restProps*/
        ctx2[20]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/
      2)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[1]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[26](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function setDifference(setA, setB) {
  let _difference = new Set(setA);
  for (let elem of setB) {
    _difference.delete(elem);
  }
  return _difference;
}
function instance_12($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "chips",
    "key",
    "selected",
    "nonInteractive",
    "choice",
    "filter",
    "input",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $filterStore;
  let $choiceStore;
  let $nonInteractiveStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Set", slots, ["default"]);
  const { MDCChipSetFoundation: MDCChipSetFoundation3 } = deprecated_exports;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { chips = [] } = $$props;
  let { key = (chip) => chip } = $$props;
  let { selected = void 0 } = $$props;
  let { nonInteractive = false } = $$props;
  let { choice = false } = $$props;
  let { filter = false } = $$props;
  let { input = false } = $$props;
  let element2;
  let instance5;
  let chipAccessorMap = {};
  let chipAccessorWeakMap = /* @__PURE__ */ new WeakMap();
  let initialSelected = chips.map((chipId) => choice && selected === chipId || filter && selected.indexOf(chipId) !== -1);
  const nonInteractiveStore = writable(nonInteractive);
  validate_store(nonInteractiveStore, "nonInteractiveStore");
  component_subscribe($$self, nonInteractiveStore, (value) => $$invalidate(31, $nonInteractiveStore = value));
  setContext("SMUI:chips:nonInteractive", nonInteractiveStore);
  const choiceStore = writable(choice);
  validate_store(choiceStore, "choiceStore");
  component_subscribe($$self, choiceStore, (value) => $$invalidate(30, $choiceStore = value));
  setContext("SMUI:chips:choice", choiceStore);
  const filterStore = writable(filter);
  validate_store(filterStore, "filterStore");
  component_subscribe($$self, filterStore, (value) => $$invalidate(29, $filterStore = value));
  setContext("SMUI:chips:filter", filterStore);
  let previousSelected = filter ? new Set(selected) : selected;
  onMount(() => {
    $$invalidate(23, instance5 = new MDCChipSetFoundation3({
      announceMessage: announce,
      focusChipPrimaryActionAtIndex: (index) => {
        var _a2;
        (_a2 = getAccessor(chips[index])) === null || _a2 === void 0 ? void 0 : _a2.focusPrimaryAction();
      },
      focusChipTrailingActionAtIndex: (index) => {
        var _a2;
        (_a2 = getAccessor(chips[index])) === null || _a2 === void 0 ? void 0 : _a2.focusTrailingAction();
      },
      getChipListCount: () => chips.length,
      getIndexOfChipById: (chipId) => chips.indexOf(chipId),
      hasClass: (className2) => getElement().classList.contains(className2),
      isRTL: () => getComputedStyle(getElement()).getPropertyValue("direction") === "rtl",
      removeChipAtIndex: (index) => {
        if (index >= 0 && index < chips.length) {
          if (choice && selected === chips[index]) {
            $$invalidate(21, selected = null);
          } else if (filter && selected.indexOf(chips[index]) !== -1) {
            selected.splice(selected.indexOf(chips[index]), 1);
            $$invalidate(21, selected);
          }
          chips.splice(index, 1);
          $$invalidate(0, chips);
        }
      },
      removeFocusFromChipAtIndex: (index) => {
        var _a2;
        (_a2 = getAccessor(chips[index])) === null || _a2 === void 0 ? void 0 : _a2.removeFocus();
      },
      selectChipAtIndex: (index, selectedValue, shouldNotifyClients) => {
        var _a2;
        if (index >= 0 && index < chips.length) {
          if (filter) {
            const selIndex = selected.indexOf(chips[index]);
            if (selectedValue && selIndex === -1) {
              selected.push(chips[index]);
              $$invalidate(21, selected);
            } else if (!selectedValue && selIndex !== -1) {
              selected.splice(selIndex, 1);
              $$invalidate(21, selected);
            }
          } else if (choice && (selectedValue || selected === chips[index])) {
            $$invalidate(21, selected = selectedValue ? chips[index] : null);
          }
          (_a2 = getAccessor(chips[index])) === null || _a2 === void 0 ? void 0 : _a2.setSelectedFromChipSet(selectedValue, shouldNotifyClients);
        }
      }
    }));
    instance5.init();
    if (choice && selected != null) {
      instance5.select(selected);
    } else if (filter && selected.length) {
      for (const chipId of selected) {
        instance5.select(chipId);
      }
    }
    return () => {
      instance5.destroy();
    };
  });
  function handleChipMount(event) {
    const accessor = event.detail;
    addAccessor(accessor.chipId, accessor);
  }
  function handleChipUnmount(event) {
    const accessor = event.detail;
    removeAccessor(accessor.chipId);
  }
  function handleChipInteraction(event) {
    if (instance5) {
      instance5.handleChipInteraction(event.detail);
    }
  }
  function handleChipSelection(event) {
    if (instance5) {
      instance5.handleChipSelection(event.detail);
    }
  }
  function handleChipRemoval(event) {
    if (instance5) {
      instance5.handleChipRemoval(event.detail);
    }
  }
  function handleChipNavigation(event) {
    if (instance5) {
      instance5.handleChipNavigation(event.detail);
    }
  }
  function getAccessor(chipId) {
    return chipId instanceof Object ? chipAccessorWeakMap.get(chipId) : chipAccessorMap[chipId];
  }
  function addAccessor(chipId, accessor) {
    if (chipId instanceof Object) {
      chipAccessorWeakMap.set(chipId, accessor);
    } else {
      chipAccessorMap[chipId] = accessor;
    }
  }
  function removeAccessor(chipId) {
    if (chipId instanceof Object) {
      chipAccessorWeakMap.delete(chipId);
    } else {
      delete chipAccessorMap[chipId];
    }
  }
  function getElement() {
    return element2;
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(8, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(20, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("chips" in $$new_props)
      $$invalidate(0, chips = $$new_props.chips);
    if ("key" in $$new_props)
      $$invalidate(3, key = $$new_props.key);
    if ("selected" in $$new_props)
      $$invalidate(21, selected = $$new_props.selected);
    if ("nonInteractive" in $$new_props)
      $$invalidate(4, nonInteractive = $$new_props.nonInteractive);
    if ("choice" in $$new_props)
      $$invalidate(5, choice = $$new_props.choice);
    if ("filter" in $$new_props)
      $$invalidate(6, filter = $$new_props.filter);
    if ("input" in $$new_props)
      $$invalidate(7, input = $$new_props.input);
    if ("$$scope" in $$new_props)
      $$invalidate(27, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    deprecated: deprecated_exports,
    onMount,
    setContext,
    writable,
    get_current_component,
    announce,
    forwardEventsBuilder,
    classMap,
    useActions,
    ContextFragment: ContextFragment_default,
    MDCChipSetFoundation: MDCChipSetFoundation3,
    forwardEvents,
    use,
    className,
    chips,
    key,
    selected,
    nonInteractive,
    choice,
    filter,
    input,
    element: element2,
    instance: instance5,
    chipAccessorMap,
    chipAccessorWeakMap,
    initialSelected,
    nonInteractiveStore,
    choiceStore,
    filterStore,
    previousSelected,
    setDifference,
    handleChipMount,
    handleChipUnmount,
    handleChipInteraction,
    handleChipSelection,
    handleChipRemoval,
    handleChipNavigation,
    getAccessor,
    addAccessor,
    removeAccessor,
    getElement,
    $filterStore,
    $choiceStore,
    $nonInteractiveStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("chips" in $$props)
      $$invalidate(0, chips = $$new_props.chips);
    if ("key" in $$props)
      $$invalidate(3, key = $$new_props.key);
    if ("selected" in $$props)
      $$invalidate(21, selected = $$new_props.selected);
    if ("nonInteractive" in $$props)
      $$invalidate(4, nonInteractive = $$new_props.nonInteractive);
    if ("choice" in $$props)
      $$invalidate(5, choice = $$new_props.choice);
    if ("filter" in $$props)
      $$invalidate(6, filter = $$new_props.filter);
    if ("input" in $$props)
      $$invalidate(7, input = $$new_props.input);
    if ("element" in $$props)
      $$invalidate(8, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(23, instance5 = $$new_props.instance);
    if ("chipAccessorMap" in $$props)
      chipAccessorMap = $$new_props.chipAccessorMap;
    if ("chipAccessorWeakMap" in $$props)
      chipAccessorWeakMap = $$new_props.chipAccessorWeakMap;
    if ("initialSelected" in $$props)
      $$invalidate(10, initialSelected = $$new_props.initialSelected);
    if ("previousSelected" in $$props)
      $$invalidate(24, previousSelected = $$new_props.previousSelected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*nonInteractive*/
    16) {
      $:
        set_store_value(nonInteractiveStore, $nonInteractiveStore = nonInteractive, $nonInteractiveStore);
    }
    if ($$self.$$.dirty[0] & /*choice*/
    32) {
      $:
        set_store_value(choiceStore, $choiceStore = choice, $choiceStore);
    }
    if ($$self.$$.dirty[0] & /*filter*/
    64) {
      $:
        set_store_value(filterStore, $filterStore = filter, $filterStore);
    }
    if ($$self.$$.dirty[0] & /*instance, choice, previousSelected, selected*/
    27263008) {
      $:
        if (instance5 && choice && previousSelected !== selected) {
          $$invalidate(24, previousSelected = selected);
          instance5.select(selected);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, filter, selected, previousSelected, chips*/
    27263041) {
      $:
        if (instance5 && filter) {
          const setSelected = new Set(selected);
          const unSelected = setDifference(previousSelected, setSelected);
          const newSelected = setDifference(setSelected, previousSelected);
          if (unSelected.size || newSelected.size) {
            $$invalidate(24, previousSelected = setSelected);
            for (let chipId of unSelected) {
              if (chips.indexOf(chipId) !== -1) {
                instance5.handleChipSelection({ chipId, selected: false });
              }
            }
            for (let chipId of newSelected) {
              instance5.handleChipSelection({ chipId, selected: true });
            }
          }
        }
    }
  };
  return [
    chips,
    use,
    className,
    key,
    nonInteractive,
    choice,
    filter,
    input,
    element2,
    forwardEvents,
    initialSelected,
    nonInteractiveStore,
    choiceStore,
    filterStore,
    handleChipMount,
    handleChipUnmount,
    handleChipInteraction,
    handleChipSelection,
    handleChipRemoval,
    handleChipNavigation,
    $$restProps,
    selected,
    getElement,
    instance5,
    previousSelected,
    slots,
    div_binding,
    $$scope
  ];
}
var Set_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_12,
      create_fragment2,
      safe_not_equal,
      {
        use: 1,
        class: 2,
        chips: 0,
        key: 3,
        selected: 21,
        nonInteractive: 4,
        choice: 5,
        filter: 6,
        input: 7,
        getElement: 22
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Set_1",
      options,
      id: create_fragment2.name
    });
  }
  get use() {
    throw new Error("<Set>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Set>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Set>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Set>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chips() {
    throw new Error("<Set>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chips(value) {
    throw new Error("<Set>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get key() {
    throw new Error("<Set>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value) {
    throw new Error("<Set>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<Set>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<Set>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nonInteractive() {
    throw new Error("<Set>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nonInteractive(value) {
    throw new Error("<Set>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get choice() {
    throw new Error("<Set>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set choice(value) {
    throw new Error("<Set>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filter() {
    throw new Error("<Set>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filter(value) {
    throw new Error("<Set>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get input() {
    throw new Error("<Set>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set input(value) {
    throw new Error("<Set>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[22];
  }
  set getElement(value) {
    throw new Error("<Set>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Set_default = Set_1;

// node_modules/@smui/chips/dist/Checkmark.svelte
var file3 = "node_modules/@smui/chips/dist/Checkmark.svelte";
function create_fragment3(ctx) {
  let span;
  let svg;
  let path;
  let span_class_value;
  let useActions_action;
  let mounted;
  let dispose;
  let span_levels = [
    {
      class: span_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-chip__checkmark": true
      })
    },
    /*$$restProps*/
    ctx[3]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      svg = svg_element("svg");
      path = svg_element("path");
      attr_dev(path, "class", "mdc-chip__checkmark-path");
      attr_dev(path, "fill", "none");
      attr_dev(path, "stroke", "black");
      attr_dev(path, "d", "M1.73,12.91 8.1,19.28 22.79,4.59");
      add_location(path, file3, 10, 4, 220);
      attr_dev(svg, "class", "mdc-chip__checkmark-svg");
      attr_dev(svg, "viewBox", "-2 -3 30 30");
      add_location(svg, file3, 9, 2, 156);
      set_attributes(span, span_data);
      add_location(span, file3, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, svg);
      append_dev(svg, path);
      ctx[5](span);
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          span,
          /*use*/
          ctx[0]
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*className*/
        2 && span_class_value !== (span_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-chip__checkmark": true
        })) && { class: span_class_value },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      ctx[5](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Checkmark", slots, []);
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let element2;
  function getElement() {
    return element2;
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
  };
  $$self.$capture_state = () => ({
    classMap,
    useActions,
    use,
    className,
    element: element2,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(2, element2 = $$new_props.element);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [use, className, element2, $$restProps, getElement, span_binding];
}
var Checkmark = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment3, safe_not_equal, { use: 0, class: 1, getElement: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Checkmark",
      options,
      id: create_fragment3.name
    });
  }
  get use() {
    throw new Error("<Checkmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Checkmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Checkmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Checkmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[4];
  }
  set getElement(value) {
    throw new Error("<Checkmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Checkmark_default = Checkmark;

// node_modules/@smui/chips/dist/Text.svelte
var file4 = "node_modules/@smui/chips/dist/Text.svelte";
function create_if_block_12(ctx) {
  let checkmark;
  let current;
  let checkmark_props = {};
  checkmark = new Checkmark_default({ props: checkmark_props, $$inline: true });
  ctx[23](checkmark);
  const block = {
    c: function create() {
      create_component(checkmark.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(checkmark, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const checkmark_changes = {};
      checkmark.$set(checkmark_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkmark.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkmark.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[23](null);
      destroy_component(checkmark, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(1:0) {#if $filter}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let span1;
  let span0;
  let span1_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  let span1_levels = [
    {
      class: span1_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-chip__primary-action": true
      })
    },
    /*$filter*/
    ctx[3] || /*$choice*/
    ctx[2] ? {
      "aria-selected": (
        /*$isSelected*/
        ctx[10] ? "true" : "false"
      )
    } : {},
    /*roleProps*/
    ctx[8],
    /*internalAttrs*/
    ctx[7],
    /*$$restProps*/
    ctx[16]
  ];
  let span_data_1 = {};
  for (let i = 0; i < span1_levels.length; i += 1) {
    span_data_1 = assign(span_data_1, span1_levels[i]);
  }
  const block = {
    c: function create() {
      span1 = element("span");
      span0 = element("span");
      if (default_slot)
        default_slot.c();
      attr_dev(span0, "class", "mdc-chip__text");
      add_location(span0, file4, 23, 23, 547);
      set_attributes(span1, span_data_1);
      add_location(span1, file4, 12, 4, 232);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span1, anchor);
      append_dev(span1, span0);
      if (default_slot) {
        default_slot.m(span0, null);
      }
      ctx[24](span1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span1, span_data_1 = get_spread_update(span1_levels, [
        (!current || dirty & /*className*/
        2 && span1_class_value !== (span1_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-chip__primary-action": true
        }))) && { class: span1_class_value },
        dirty & /*$filter, $choice, $isSelected*/
        1036 && /*$filter*/
        (ctx2[3] || /*$choice*/
        ctx2[2] ? {
          "aria-selected": (
            /*$isSelected*/
            ctx2[10] ? "true" : "false"
          )
        } : {}),
        dirty & /*roleProps*/
        256 && /*roleProps*/
        ctx2[8],
        dirty & /*internalAttrs*/
        128 && /*internalAttrs*/
        ctx2[7],
        dirty & /*$$restProps*/
        65536 && /*$$restProps*/
        ctx2[16]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span1);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[24](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(12:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let span;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      attr_dev(span, "class", "mdc-chip__text");
      add_location(span, file4, 10, 4, 173);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(10:2) {#if $nonInteractive}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let t;
  let span;
  let current_block_type_index;
  let if_block1;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$filter*/
    ctx[3] && create_if_block_12(ctx)
  );
  const if_block_creators = [create_if_block2, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$nonInteractive*/
      ctx2[9]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      span = element("span");
      if_block1.c();
      attr_dev(span, "role", "gridcell");
      add_location(span, file4, 3, 0, 54);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t, anchor);
      insert_dev(target, span, anchor);
      if_blocks[current_block_type_index].m(span, null);
      ctx[25](span);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[11].call(null, span))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$filter*/
        ctx2[3]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$filter*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_12(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(span, null);
      }
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(span);
      }
      if (if_block0)
        if_block0.d(detaching);
      if_blocks[current_block_type_index].d();
      ctx[25](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let roleProps;
  const omit_props_names = ["use", "class", "tabindex", "focus", "getInput", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $choice;
  let $filter;
  let $nonInteractive;
  let $isSelected;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Text", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { tabindex = getContext("SMUI:chips:chip:focusable") ? 0 : -1 } = $$props;
  let element2;
  let input = void 0;
  let primaryAction = void 0;
  let internalAttrs = {};
  const nonInteractive = getContext("SMUI:chips:nonInteractive");
  validate_store(nonInteractive, "nonInteractive");
  component_subscribe($$self, nonInteractive, (value) => $$invalidate(9, $nonInteractive = value));
  const choice = getContext("SMUI:chips:choice");
  validate_store(choice, "choice");
  component_subscribe($$self, choice, (value) => $$invalidate(2, $choice = value));
  const filter = getContext("SMUI:chips:filter");
  validate_store(filter, "filter");
  component_subscribe($$self, filter, (value) => $$invalidate(3, $filter = value));
  const isSelected = getContext("SMUI:chips:chip:isSelected");
  validate_store(isSelected, "isSelected");
  component_subscribe($$self, isSelected, (value) => $$invalidate(10, $isSelected = value));
  onMount(() => {
    let accessor = { focus, addAttr };
    dispatch(getElement(), "SMUIChipsChipPrimaryAction:mount", accessor);
    return () => {
      dispatch(getElement(), "SMUIChipsChipPrimaryAction:unmount", accessor);
    };
  });
  function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
      $$invalidate(7, internalAttrs[name] = value, internalAttrs);
    }
  }
  function waitForTabindex(fn) {
    if (internalAttrs["tabindex"] !== element2.getAttribute("tabindex")) {
      tick().then(fn);
    } else {
      fn();
    }
  }
  function focus() {
    waitForTabindex(() => {
      primaryAction && primaryAction.focus();
    });
  }
  function getInput() {
    return input && input.getElement();
  }
  function getElement() {
    return element2;
  }
  function checkmark_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(5, input);
    });
  }
  function span1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      primaryAction = $$value;
      $$invalidate(6, primaryAction);
    });
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(4, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("tabindex" in $$new_props)
      $$invalidate(17, tabindex = $$new_props.tabindex);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    getContext,
    tick,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    dispatch,
    Checkmark: Checkmark_default,
    forwardEvents,
    use,
    className,
    tabindex,
    element: element2,
    input,
    primaryAction,
    internalAttrs,
    nonInteractive,
    choice,
    filter,
    isSelected,
    addAttr,
    waitForTabindex,
    focus,
    getInput,
    getElement,
    roleProps,
    $choice,
    $filter,
    $nonInteractive,
    $isSelected
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("tabindex" in $$props)
      $$invalidate(17, tabindex = $$new_props.tabindex);
    if ("element" in $$props)
      $$invalidate(4, element2 = $$new_props.element);
    if ("input" in $$props)
      $$invalidate(5, input = $$new_props.input);
    if ("primaryAction" in $$props)
      $$invalidate(6, primaryAction = $$new_props.primaryAction);
    if ("internalAttrs" in $$props)
      $$invalidate(7, internalAttrs = $$new_props.internalAttrs);
    if ("roleProps" in $$props)
      $$invalidate(8, roleProps = $$new_props.roleProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$filter, $choice, tabindex*/
    131084) {
      $:
        $$invalidate(8, roleProps = {
          role: $filter ? "checkbox" : $choice ? "radio" : "button",
          tabindex
        });
    }
  };
  return [
    use,
    className,
    $choice,
    $filter,
    element2,
    input,
    primaryAction,
    internalAttrs,
    roleProps,
    $nonInteractive,
    $isSelected,
    forwardEvents,
    nonInteractive,
    choice,
    filter,
    isSelected,
    $$restProps,
    tabindex,
    focus,
    getInput,
    getElement,
    $$scope,
    slots,
    checkmark_binding,
    span1_binding,
    span_binding
  ];
}
var Text = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment4, safe_not_equal, {
      use: 0,
      class: 1,
      tabindex: 17,
      focus: 18,
      getInput: 19,
      getElement: 20
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Text",
      options,
      id: create_fragment4.name
    });
  }
  get use() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    return this.$$.ctx[18];
  }
  set focus(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getInput() {
    return this.$$.ctx[19];
  }
  set getInput(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[20];
  }
  set getElement(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Text_default = Text;

// node_modules/@smui/chips/dist/LeadingIcon.svelte
var file5 = "node_modules/@smui/chips/dist/LeadingIcon.svelte";
function create_fragment5(ctx) {
  let i;
  let i_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  let i_levels = [
    {
      class: i_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-chip__icon": true,
        "mdc-chip__icon--leading": true,
        "mdc-chip__icon--leading-hidden": (
          /*$filter*/
          ctx[3] && /*$isSelected*/
          ctx[4]
        ),
        .../*$leadingIconClasses*/
        ctx[5]
      })
    },
    /*$$restProps*/
    ctx[10]
  ];
  let i_data = {};
  for (let i2 = 0; i2 < i_levels.length; i2 += 1) {
    i_data = assign(i_data, i_levels[i2]);
  }
  const block = {
    c: function create() {
      i = element("i");
      if (default_slot)
        default_slot.c();
      set_attributes(i, i_data);
      add_location(i, file5, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, i, anchor);
      if (default_slot) {
        default_slot.m(i, null);
      }
      ctx[14](i);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            i,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[6].call(null, i))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(i, i_data = get_spread_update(i_levels, [
        (!current || dirty & /*className, $filter, $isSelected, $leadingIconClasses*/
        58 && i_class_value !== (i_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-chip__icon": true,
          "mdc-chip__icon--leading": true,
          "mdc-chip__icon--leading-hidden": (
            /*$filter*/
            ctx2[3] && /*$isSelected*/
            ctx2[4]
          ),
          .../*$leadingIconClasses*/
          ctx2[5]
        }))) && { class: i_class_value },
        dirty & /*$$restProps*/
        1024 && /*$$restProps*/
        ctx2[10]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(i);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[14](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $filter;
  let $isSelected;
  let $leadingIconClasses;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LeadingIcon", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  const filter = getContext("SMUI:chips:filter");
  validate_store(filter, "filter");
  component_subscribe($$self, filter, (value) => $$invalidate(3, $filter = value));
  const isSelected = getContext("SMUI:chips:chip:isSelected");
  validate_store(isSelected, "isSelected");
  component_subscribe($$self, isSelected, (value) => $$invalidate(4, $isSelected = value));
  const leadingIconClasses = getContext("SMUI:chips:chip:leadingIconClasses");
  validate_store(leadingIconClasses, "leadingIconClasses");
  component_subscribe($$self, leadingIconClasses, (value) => $$invalidate(5, $leadingIconClasses = value));
  let element2;
  function getElement() {
    return element2;
  }
  function i_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    filter,
    isSelected,
    leadingIconClasses,
    element: element2,
    getElement,
    $filter,
    $isSelected,
    $leadingIconClasses
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(2, element2 = $$new_props.element);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    element2,
    $filter,
    $isSelected,
    $leadingIconClasses,
    forwardEvents,
    filter,
    isSelected,
    leadingIconClasses,
    $$restProps,
    getElement,
    $$scope,
    slots,
    i_binding
  ];
}
var LeadingIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment5, safe_not_equal, { use: 0, class: 1, getElement: 11 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LeadingIcon",
      options,
      id: create_fragment5.name
    });
  }
  get use() {
    throw new Error("<LeadingIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<LeadingIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<LeadingIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<LeadingIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[11];
  }
  set getElement(value) {
    throw new Error("<LeadingIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LeadingIcon_default = LeadingIcon;

// node_modules/@smui/chips/dist/TrailingIcon.svelte
var file6 = "node_modules/@smui/chips/dist/TrailingIcon.svelte";
function create_fragment6(ctx) {
  let span;
  let i;
  let i_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let i_levels = [
    {
      class: i_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-chip__icon": true,
        "mdc-chip__icon--trailing": true
      })
    },
    /*$$restProps*/
    ctx[4]
  ];
  let i_data = {};
  for (let i2 = 0; i2 < i_levels.length; i2 += 1) {
    i_data = assign(i_data, i_levels[i2]);
  }
  const block = {
    c: function create() {
      span = element("span");
      i = element("i");
      if (default_slot)
        default_slot.c();
      set_attributes(i, i_data);
      add_location(i, file6, 6, 2, 93);
      attr_dev(span, "role", "gridcell");
      add_location(span, file6, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, i);
      if (default_slot) {
        default_slot.m(i, null);
      }
      ctx[8](span);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[3].call(null, span))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(i, i_data = get_spread_update(i_levels, [
        (!current || dirty & /*className*/
        2 && i_class_value !== (i_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-chip__icon": true,
          "mdc-chip__icon--trailing": true
        }))) && { class: i_class_value },
        dirty & /*$$restProps*/
        16 && /*$$restProps*/
        ctx2[4]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[8](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TrailingIcon", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let element2;
  function getElement() {
    return element2;
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    element: element2,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(2, element2 = $$new_props.element);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    element2,
    forwardEvents,
    $$restProps,
    getElement,
    $$scope,
    slots,
    span_binding
  ];
}
var TrailingIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment6, safe_not_equal, { use: 0, class: 1, getElement: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TrailingIcon",
      options,
      id: create_fragment6.name
    });
  }
  get use() {
    throw new Error("<TrailingIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<TrailingIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TrailingIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TrailingIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[5];
  }
  set getElement(value) {
    throw new Error("<TrailingIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TrailingIcon_default = TrailingIcon;

// node_modules/@smui/chips/dist/TrailingAction.svelte
var file7 = "node_modules/@smui/chips/dist/TrailingAction.svelte";
function create_if_block3(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      attr_dev(span, "class", "mdc-deprecated-chip-trailing-action__touch");
      add_location(span, file7, 30, 4, 773);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(30:2) {#if touch}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let button;
  let span0;
  let t0;
  let t1;
  let span1;
  let span1_class_value;
  let useActions_action;
  let button_class_value;
  let button_style_value;
  let button_aria_hidden_value;
  let Ripple_action;
  let useActions_action_1;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*touch*/
    ctx[4] && create_if_block3(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    null
  );
  let span1_levels = [
    {
      class: span1_class_value = classMap({
        [
          /*icon$class*/
          ctx[7]
        ]: true,
        "mdc-deprecated-chip-trailing-action__icon": true
      })
    },
    prefixFilter(
      /*$$restProps*/
      ctx[17],
      "icon$"
    )
  ];
  let span_data = {};
  for (let i = 0; i < span1_levels.length; i += 1) {
    span_data = assign(span_data, span1_levels[i]);
  }
  let button_levels = [
    { type: "button" },
    {
      class: button_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-deprecated-chip-trailing-action": true,
        .../*internalClasses*/
        ctx[10]
      })
    },
    {
      style: button_style_value = Object.entries(
        /*internalStyles*/
        ctx[11]
      ).map(func2).concat([
        /*style*/
        ctx[2]
      ]).join(" ")
    },
    {
      "aria-hidden": button_aria_hidden_value = /*nonNavigable*/
      ctx[5] ? "true" : void 0
    },
    { tabindex: "-1" },
    /*internalAttrs*/
    ctx[12],
    exclude(
      /*$$restProps*/
      ctx[17],
      ["icon$"]
    )
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      span0 = element("span");
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      span1 = element("span");
      if (default_slot)
        default_slot.c();
      attr_dev(span0, "class", "mdc-deprecated-chip-trailing-action__ripple");
      add_location(span0, file7, 28, 2, 694);
      set_attributes(span1, span_data);
      add_location(span1, file7, 32, 2, 843);
      set_attributes(button, button_data);
      add_location(button, file7, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      append_dev(button, span0);
      append_dev(button, t0);
      if (if_block)
        if_block.m(button, null);
      append_dev(button, t1);
      append_dev(button, span1);
      if (default_slot) {
        default_slot.m(span1, null);
      }
      if (button.autofocus)
        button.focus();
      ctx[24](button);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span1,
            /*icon$use*/
            ctx[6]
          )),
          action_destroyer(Ripple_action = dist_default.call(null, button, {
            ripple: (
              /*ripple*/
              ctx[3]
            ),
            unbounded: false,
            addClass: (
              /*addClass*/
              ctx[14]
            ),
            removeClass: (
              /*removeClass*/
              ctx[15]
            ),
            addStyle: (
              /*addStyle*/
              ctx[16]
            )
          })),
          action_destroyer(useActions_action_1 = useActions.call(
            null,
            button,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[13].call(null, button)),
          listen_dev(
            button,
            "click",
            function() {
              if (is_function(
                /*instance*/
                ctx[9] && /*instance*/
                ctx[9].handleClick.bind(
                  /*instance*/
                  ctx[9]
                )
              ))
                /*instance*/
                (ctx[9] && /*instance*/
                ctx[9].handleClick.bind(
                  /*instance*/
                  ctx[9]
                )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keydown",
            function() {
              if (is_function(
                /*instance*/
                ctx[9] && /*instance*/
                ctx[9].handleKeydown.bind(
                  /*instance*/
                  ctx[9]
                )
              ))
                /*instance*/
                (ctx[9] && /*instance*/
                ctx[9].handleKeydown.bind(
                  /*instance*/
                  ctx[9]
                )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (
        /*touch*/
        ctx[4]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block3(ctx);
          if_block.c();
          if_block.m(button, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[22],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span1, span_data = get_spread_update(span1_levels, [
        (!current || dirty & /*icon$class*/
        128 && span1_class_value !== (span1_class_value = classMap({
          [
            /*icon$class*/
            ctx[7]
          ]: true,
          "mdc-deprecated-chip-trailing-action__icon": true
        }))) && { class: span1_class_value },
        dirty & /*$$restProps*/
        131072 && prefixFilter(
          /*$$restProps*/
          ctx[17],
          "icon$"
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*icon$use*/
      64)
        useActions_action.update.call(
          null,
          /*icon$use*/
          ctx[6]
        );
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        (!current || dirty & /*className, internalClasses*/
        1026 && button_class_value !== (button_class_value = classMap({
          [
            /*className*/
            ctx[1]
          ]: true,
          "mdc-deprecated-chip-trailing-action": true,
          .../*internalClasses*/
          ctx[10]
        }))) && { class: button_class_value },
        (!current || dirty & /*internalStyles, style*/
        2052 && button_style_value !== (button_style_value = Object.entries(
          /*internalStyles*/
          ctx[11]
        ).map(func2).concat([
          /*style*/
          ctx[2]
        ]).join(" "))) && { style: button_style_value },
        (!current || dirty & /*nonNavigable*/
        32 && button_aria_hidden_value !== (button_aria_hidden_value = /*nonNavigable*/
        ctx[5] ? "true" : void 0)) && { "aria-hidden": button_aria_hidden_value },
        { tabindex: "-1" },
        dirty & /*internalAttrs*/
        4096 && /*internalAttrs*/
        ctx[12],
        dirty & /*$$restProps*/
        131072 && exclude(
          /*$$restProps*/
          ctx[17],
          ["icon$"]
        )
      ]));
      if (Ripple_action && is_function(Ripple_action.update) && dirty & /*ripple*/
      8)
        Ripple_action.update.call(null, {
          ripple: (
            /*ripple*/
            ctx[3]
          ),
          unbounded: false,
          addClass: (
            /*addClass*/
            ctx[14]
          ),
          removeClass: (
            /*removeClass*/
            ctx[15]
          ),
          addStyle: (
            /*addStyle*/
            ctx[16]
          )
        });
      if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*use*/
      1)
        useActions_action_1.update.call(
          null,
          /*use*/
          ctx[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[24](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func2 = ([name, value]) => `${name}: ${value};`;
function instance_13($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "ripple",
    "touch",
    "nonNavigable",
    "icon$use",
    "icon$class",
    "isNavigable",
    "focus",
    "removeFocus",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TrailingAction", slots, ["default"]);
  const { MDCChipTrailingActionFoundation: MDCChipTrailingActionFoundation3 } = deprecated_exports;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { ripple = true } = $$props;
  let { touch = false } = $$props;
  let { nonNavigable = false } = $$props;
  let { icon$use = [] } = $$props;
  let { icon$class = "" } = $$props;
  let element2;
  let instance5;
  let internalClasses = {};
  let internalStyles = {};
  let internalAttrs = {};
  onMount(() => {
    $$invalidate(9, instance5 = new MDCChipTrailingActionFoundation3({
      focus: () => {
        const element3 = getElement();
        waitForTabindex(() => {
          element3.focus();
        });
      },
      getAttribute: getAttr,
      notifyInteraction: (trigger) => dispatch(getElement(), "SMUIChipTrailingAction:interaction", { trigger }, void 0, true),
      notifyNavigation: (key) => {
        dispatch(getElement(), "SMUIChipTrailingAction:navigation", { key }, void 0, true);
      },
      setAttribute: addAttr
    }));
    const accessor = { isNavigable, focus, removeFocus };
    dispatch(getElement(), "SMUIChipsChipTrailingAction:mount", accessor);
    instance5.init();
    return () => {
      dispatch(getElement(), "SMUIChipsChipTrailingAction:unmount", accessor);
      instance5.destroy();
    };
  });
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(10, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(10, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(11, internalStyles);
      } else {
        $$invalidate(11, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function getAttr(name) {
    var _a2;
    return name in internalAttrs ? (_a2 = internalAttrs[name]) !== null && _a2 !== void 0 ? _a2 : null : getElement().getAttribute(name);
  }
  function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
      $$invalidate(12, internalAttrs[name] = value, internalAttrs);
    }
  }
  function waitForTabindex(fn) {
    if (internalAttrs["tabindex"] !== element2.getAttribute("tabindex")) {
      tick().then(fn);
    } else {
      fn();
    }
  }
  function isNavigable() {
    return instance5.isNavigable();
  }
  function focus() {
    instance5.focus();
  }
  function removeFocus() {
    instance5.removeFocus();
  }
  function getElement() {
    return element2;
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(8, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(2, style = $$new_props.style);
    if ("ripple" in $$new_props)
      $$invalidate(3, ripple = $$new_props.ripple);
    if ("touch" in $$new_props)
      $$invalidate(4, touch = $$new_props.touch);
    if ("nonNavigable" in $$new_props)
      $$invalidate(5, nonNavigable = $$new_props.nonNavigable);
    if ("icon$use" in $$new_props)
      $$invalidate(6, icon$use = $$new_props.icon$use);
    if ("icon$class" in $$new_props)
      $$invalidate(7, icon$class = $$new_props.icon$class);
    if ("$$scope" in $$new_props)
      $$invalidate(22, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    deprecated: deprecated_exports,
    onMount,
    tick,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    exclude,
    prefixFilter,
    useActions,
    dispatch,
    Ripple: dist_default,
    MDCChipTrailingActionFoundation: MDCChipTrailingActionFoundation3,
    forwardEvents,
    use,
    className,
    style,
    ripple,
    touch,
    nonNavigable,
    icon$use,
    icon$class,
    element: element2,
    instance: instance5,
    internalClasses,
    internalStyles,
    internalAttrs,
    addClass,
    removeClass,
    addStyle,
    getAttr,
    addAttr,
    waitForTabindex,
    isNavigable,
    focus,
    removeFocus,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(2, style = $$new_props.style);
    if ("ripple" in $$props)
      $$invalidate(3, ripple = $$new_props.ripple);
    if ("touch" in $$props)
      $$invalidate(4, touch = $$new_props.touch);
    if ("nonNavigable" in $$props)
      $$invalidate(5, nonNavigable = $$new_props.nonNavigable);
    if ("icon$use" in $$props)
      $$invalidate(6, icon$use = $$new_props.icon$use);
    if ("icon$class" in $$props)
      $$invalidate(7, icon$class = $$new_props.icon$class);
    if ("element" in $$props)
      $$invalidate(8, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(9, instance5 = $$new_props.instance);
    if ("internalClasses" in $$props)
      $$invalidate(10, internalClasses = $$new_props.internalClasses);
    if ("internalStyles" in $$props)
      $$invalidate(11, internalStyles = $$new_props.internalStyles);
    if ("internalAttrs" in $$props)
      $$invalidate(12, internalAttrs = $$new_props.internalAttrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    style,
    ripple,
    touch,
    nonNavigable,
    icon$use,
    icon$class,
    element2,
    instance5,
    internalClasses,
    internalStyles,
    internalAttrs,
    forwardEvents,
    addClass,
    removeClass,
    addStyle,
    $$restProps,
    isNavigable,
    focus,
    removeFocus,
    getElement,
    $$scope,
    slots,
    button_binding
  ];
}
var TrailingAction = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_13, create_fragment7, safe_not_equal, {
      use: 0,
      class: 1,
      style: 2,
      ripple: 3,
      touch: 4,
      nonNavigable: 5,
      icon$use: 6,
      icon$class: 7,
      isNavigable: 18,
      focus: 19,
      removeFocus: 20,
      getElement: 21
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TrailingAction",
      options,
      id: create_fragment7.name
    });
  }
  get use() {
    throw new Error("<TrailingAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TrailingAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<TrailingAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ripple() {
    throw new Error("<TrailingAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ripple(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get touch() {
    throw new Error("<TrailingAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set touch(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nonNavigable() {
    throw new Error("<TrailingAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nonNavigable(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon$use() {
    throw new Error("<TrailingAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon$use(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon$class() {
    throw new Error("<TrailingAction>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon$class(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isNavigable() {
    return this.$$.ctx[18];
  }
  set isNavigable(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    return this.$$.ctx[19];
  }
  set focus(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get removeFocus() {
    return this.$$.ctx[20];
  }
  set removeFocus(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[21];
  }
  set getElement(value) {
    throw new Error("<TrailingAction>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TrailingAction_default = TrailingAction;

// node_modules/@smui/chips/dist/index.js
var dist_default2 = Chip_default;
export {
  LeadingIcon_default as LeadingIcon,
  Set_default as Set,
  Text_default as Text,
  TrailingAction_default as TrailingAction,
  TrailingIcon_default as TrailingIcon,
  dist_default2 as default
};
/*! Bundled license information:

@material/chips/action/adapter.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/action/component-ripple.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/action/constants.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/action/foundation.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/action/primary-foundation.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/action/trailing-foundation.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/action/component.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/action/types.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/action/index.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/chip/adapter.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/chip/constants.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/chip/foundation.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/chip/component.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/chip/types.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/chip/index.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/chip-set/adapter.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/dom/announce.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/chip-set/constants.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/chip-set/foundation.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/chip-set/component.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/chip-set/types.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/chip-set/index.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/deprecated/trailingaction/adapter.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/deprecated/trailingaction/constants.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/deprecated/trailingaction/foundation.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/deprecated/trailingaction/component.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/deprecated/trailingaction/types.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/deprecated/trailingaction/index.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/deprecated/chip/adapter.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/deprecated/chip/constants.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/deprecated/chip/foundation.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/deprecated/chip/component.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/deprecated/chip/types.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/deprecated/chip/index.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/deprecated/chip-set/adapter.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/deprecated/chip-set/constants.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/deprecated/chip-set/foundation.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/deprecated/chip-set/component.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/deprecated/chip-set/index.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/deprecated/index.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/chips/index.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/ripple/adapter.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/ripple/types.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/ripple/index.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)
*/
//# sourceMappingURL=@smui_chips.js.map
